import { jsPDF } from 'jspdf';

export interface ComprehensiveExportData {
  // Company & Organization Info
  companyName: string;
  organizationName: string;
  companyTaxId?: string;
  industry?: string;
  contactEmail?: string;
  website?: string;
  
  // Report Meta Data
  reportType: 'pnl' | 'cashflow';
  locale: string;
  currency: string;
  currentPeriod: string;
  currentPeriodIndex: number;
  generatedBy: string;
  generatedAt: string;
  lastUpdate: string;
  
  // Financial Data Arrays
  periods: string[];
  
  // Cash Flow specific (optional)
  totalInflows?: { values: number[] };
  totalOutflows?: { values: number[] };
  netCashFlow?: { values: number[] };
  initialBalance?: { values: number[] };
  finalBalance?: { values: number[] };
  monthlyGeneration?: { values: number[] };
  
  // P&L specific (optional)
  totalRevenues?: { values: number[] };
  totalCosts?: { values: number[] };
  grossProfit?: { values: number[] };
  operatingExpenses?: { values: number[] };
  netIncome?: { values: number[] };
  ebitda?: { values: number[] };
  
  // Calculated Summaries - flexible for both report types
  currentMonthSummary: any;
  ytdSummary: any;
  annualProjections: any;
  growthTrends: number[];
  
  // Enhanced Data
  yearToDate?: any;
  projectedAnnual?: any;
  categories?: any;
  forecasts?: any;
  lineItems?: any;
  summary?: any;
  
  // Configuration data
  lastActualPeriod?: any;
  lastActualPeriodLabel?: string;
  periodMetadata?: { [key: string]: { isActual?: boolean; isProjected?: boolean } };
}

export class ProfessionalPDFExportService {
  private formatCurrency(value: number | undefined, locale: string = 'en', currency: string = 'USD'): string {
    if (!value) return '$0';
    
    const absValue = Math.abs(value);
    
    // Format for large values
    if (absValue >= 1000000) {
      return `${currency === 'USD' ? '$' : currency}${(value / 1000000).toFixed(1)}M`;
    }
    if (absValue >= 1000) {
      return `${currency === 'USD' ? '$' : currency}${(value / 1000).toFixed(0)}K`;
    }
    
    return new Intl.NumberFormat(locale.startsWith('es') ? 'es-ES' : 'en-US', {
      style: 'currency',
      currency: currency === 'USD' ? 'USD' : currency,
      maximumFractionDigits: 0
    }).format(value);
  }

  private async getTranslations(locale: string, reportType: string) {
    try {
      const langCode = locale.startsWith('es') ? 'es' : 'en';
      const translations = await import(`../../locales/${langCode}/export.json`);
      
      const t = translations.default;
      return {
        // Report info
        title: reportType === 'cashflow' ? t.report.cashflow_title : t.report.pnl_title,
        currentPeriod: langCode === 'es' ? 'Período Actual' : 'Current Period',
        
        // Company info
        companyInfo: langCode === 'es' ? 'Información de la Empresa' : 'Company Information',
        industry: langCode === 'es' ? 'Industria' : 'Industry',
        taxId: langCode === 'es' ? 'RUC/NIT' : 'Tax ID',
        contact: langCode === 'es' ? 'Contacto' : 'Contact',
        website: langCode === 'es' ? 'Sitio Web' : 'Website',
        lastUpdated: langCode === 'es' ? 'Última Actualización' : 'Last Updated',
        generatedBy: langCode === 'es' ? 'Generado por' : 'Generated by',
        
        // Cash flow sections
        currentMonthSummary: t.cashflow.currentMonthSummary,
        ytdSummary: t.cashflow.ytdSummary,
        annualProjections: t.cashflow.annualProjections,
        
        // Current month fields
        balanceInicial: t.cashflow.balanceInicial,
        entradasTotales: t.cashflow.entradasTotales,
        salidasTotales: t.cashflow.salidasTotales,
        balanceFinal: t.cashflow.balanceFinal,
        generacionMensual: t.cashflow.generacionMensual,
        
        // YTD fields
        entradasYTD: t.cashflow.entradasYTD,
        salidasYTD: t.cashflow.salidasYTD,
        flujoNetoYTD: t.cashflow.flujoNetoYTD,
        generacionPromMensual: t.cashflow.generacionPromMensual,
        
        // Annual projection fields
        entradasProyectadas: t.cashflow.entradasProyectadas,
        salidasProyectadas: t.cashflow.salidasProyectadas,
        flujoNetoProyectado: t.cashflow.flujoNetoProyectado,
        generacionPromProyectada: t.cashflow.generacionPromProyectada,
        
        // Charts
        growthAnalysis: t.cashflow.charts.growthAnalysis,
        balanceTrends: t.cashflow.charts.balanceTrends,
        composition: t.cashflow.charts.composition,
        monthlyPerformance: t.cashflow.charts.monthlyPerformance,
        
        // Table headers
        periodo: t.cashflow.table.periodo,
        entradas: t.cashflow.table.entradas,
        salidas: t.cashflow.table.salidas,
        crecimiento: t.cashflow.table.crecimiento,
        status: t.cashflow.table.status,
        
        // Footer
        confidential: t.report.confidential,
        page: t.report.page,
        of: t.report.of
      };
    } catch (error) {
      console.error('Error loading translations:', error);
      // Fallback to English
      const isSpanish = locale.startsWith('es');
      return {
        title: reportType === 'cashflow' 
          ? (isSpanish ? 'Análisis de Flujo de Caja' : 'Cash Flow Analysis')
          : (isSpanish ? 'Estado de Resultados' : 'Profit & Loss Statement'),
        currentMonthSummary: isSpanish ? 'Resumen de Cash Flow' : 'Cash Flow Summary',
        // ... other fallback translations
      };
    }
  }

  private calculateTrend(values: number[]): number {
    if (values.length < 2) return 0;
    const current = values[values.length - 1];
    const previous = values[values.length - 2];
    if (!previous || previous === 0) return 0;
    return ((current - previous) / Math.abs(previous)) * 100;
  }

  private calculateYTDSum(values: number[]): number {
    return values.reduce((sum, val) => sum + (val || 0), 0);
  }

  private drawCardSection(
    pdf: jsPDF, 
    cards: Array<{label: string, value: string, color: string}>, 
    startX: number, 
    startY: number, 
    cardWidth: number, 
    cardHeight: number, 
    cardGap: number, 
    cardsPerRow: number
  ) {
    for (let i = 0; i < cards.length; i++) {
      const col = i % cardsPerRow;
      const x = startX + col * (cardWidth + cardGap);
      const cardY = startY;

      // Card background
      pdf.setFillColor(248, 250, 252);
      pdf.roundedRect(x, cardY, cardWidth, cardHeight, 2, 2, 'F');
      
      // Card border
      pdf.setDrawColor(226, 232, 240);
      pdf.roundedRect(x, cardY, cardWidth, cardHeight, 2, 2, 'S');
      
      // Value (large)
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'bold');
      const colorRgb = this.hexToRgb(cards[i].color);
      pdf.setTextColor(colorRgb.r, colorRgb.g, colorRgb.b);
      pdf.text(cards[i].value, x + cardWidth/2, cardY + 10, { align: 'center' });
      
      // Label (small)
      pdf.setFontSize(7);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(107, 114, 128);
      // Split long labels to fit in narrow cards
      const label = cards[i].label;
      if (label.length > 12) {
        const words = label.split(' ');
        if (words.length > 1) {
          pdf.text(words[0], x + cardWidth/2, cardY + 17, { align: 'center' });
          pdf.text(words.slice(1).join(' '), x + cardWidth/2, cardY + 20, { align: 'center' });
        } else {
          pdf.text(label.substring(0, 12) + '...', x + cardWidth/2, cardY + 18, { align: 'center' });
        }
      } else {
        pdf.text(label, x + cardWidth/2, cardY + 18, { align: 'center' });
      }
    }
  }

  async generateProfessionalPDF(data: ComprehensiveExportData): Promise<Buffer> {
    const t = await this.getTranslations(data.locale, data.reportType);
    
    // Create PDF with A4 size
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Warren Dashboard Color Palette
    const primaryColor = '#8B5CF6'; // Warren Purple
    const secondaryColor = '#06B6D4'; // Warren Cyan
    const successColor = '#10B981'; // Emerald
    const warningColor = '#F59E0B'; // Amber
    const dangerColor = '#EF4444'; // Red
    const textColor = '#374151'; // Gray
    const lightGray = '#f8fafc';
    const borderGray = '#e2e8f0';
    const gridColor = '#f1f5f9';
    const accentColor = '#3B82F6'; // Blue
    
    // Gradient colors (lighter versions for gradients)
    const primaryLight = '#A78BFA'; // Light purple
    const secondaryLight = '#67E8F9'; // Light cyan
    const successLight = '#34D399'; // Light emerald
    const dangerLight = '#FB7185'; // Light red
    
    let y = 20;
    const pageHeight = pdf.internal.pageSize.height;
    const pageWidth = pdf.internal.pageSize.width;
    const margin = 20;

    // HEADER SECTION - Enhanced
    pdf.setFillColor(30, 64, 175); // Blue background
    pdf.rect(0, 0, pageWidth, 55, 'F');
    
    // Organization and Company names
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(24);
    pdf.setFont('helvetica', 'bold');
    pdf.text(data.companyName, 105, 20, { align: 'center' });
    
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    pdf.text(data.organizationName, 105, 28, { align: 'center' });
    
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t.title, 105, 36, { align: 'center' });
    
    // Current period highlight
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.text(`${t.currentPeriod}: ${data.currentPeriod}`, 105, 46, { align: 'center' });

    y = 65;

    // COMPANY INFORMATION SECTION
    pdf.setTextColor(textColor);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t.companyInfo || 'Company Information', margin, y);
    y += 8;

    // Company info in two columns
    const leftColX = margin;
    const rightColX = pageWidth / 2 + 10;
    
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'normal');
    
    if (data.companyTaxId) {
      pdf.text(`${t.taxId}: ${data.companyTaxId}`, leftColX, y);
    }
    if (data.industry) {
      pdf.text(`${t.industry}: ${data.industry}`, rightColX, y);
    }
    y += 5;
    
    if (data.contactEmail) {
      pdf.text(`${t.contact}: ${data.contactEmail}`, leftColX, y);
    }
    if (data.website) {
      pdf.text(`${t.website}: ${data.website}`, rightColX, y);
    }
    y += 5;
    
    pdf.text(`${t.lastUpdated}: ${new Date(data.lastUpdate).toLocaleDateString(data.locale)}`, leftColX, y);
    pdf.text(`${t.generatedBy}: ${data.generatedBy}`, rightColX, y);
    y += 15;

    // SECTION 1: RESUMEN DE CASH FLOW (CURRENT MONTH)
    pdf.setTextColor(textColor);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t.currentMonthSummary + ` - ${data.currentPeriod}`, margin, y);
    y += 10;

    // Current Month Cards (5 in a row)
    const cardWidth = 32;
    const cardHeight = 22;
    const cardGap = 6;
    
    const currentMonthCards = [
      { 
        label: t.balanceInicial, 
        value: this.formatCurrency(data.currentMonthSummary.balanceInicial, data.locale, data.currency),
        color: '#6366f1' 
      },
      { 
        label: t.entradasTotales, 
        value: this.formatCurrency(data.currentMonthSummary.entradasTotales, data.locale, data.currency),
        color: secondaryColor 
      },
      { 
        label: t.salidasTotales, 
        value: this.formatCurrency(data.currentMonthSummary.salidasTotales, data.locale, data.currency),
        color: dangerColor 
      },
      { 
        label: t.balanceFinal, 
        value: this.formatCurrency(data.currentMonthSummary.balanceFinal, data.locale, data.currency),
        color: data.currentMonthSummary.balanceFinal >= 0 ? successColor : dangerColor 
      },
      { 
        label: t.generacionMensual, 
        value: this.formatCurrency(data.currentMonthSummary.generacionMensual, data.locale, data.currency),
        color: data.currentMonthSummary.generacionMensual >= 0 ? successColor : dangerColor 
      }
    ];

    this.drawCardSection(pdf, currentMonthCards, margin, y, cardWidth, cardHeight, cardGap, 5);
    y += 35;

    // SECTION 2: RESUMEN ANUAL ACUMULADO (YTD)
    pdf.setTextColor(textColor);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t.ytdSummary, margin, y);
    y += 10;

    // YTD Cards (4 in a row)
    const ytdCardWidth = 40;
    const ytdCards = [
      { 
        label: t.entradasYTD, 
        value: this.formatCurrency(data.ytdSummary.entradasYTD, data.locale, data.currency),
        color: secondaryColor 
      },
      { 
        label: t.salidasYTD, 
        value: this.formatCurrency(data.ytdSummary.salidasYTD, data.locale, data.currency),
        color: dangerColor 
      },
      { 
        label: t.flujoNetoYTD, 
        value: this.formatCurrency(data.ytdSummary.flujoNetoYTD, data.locale, data.currency),
        color: data.ytdSummary.flujoNetoYTD >= 0 ? successColor : dangerColor 
      },
      { 
        label: t.generacionPromMensual, 
        value: this.formatCurrency(data.ytdSummary.generacionPromMensual, data.locale, data.currency),
        color: primaryColor 
      }
    ];

    this.drawCardSection(pdf, ytdCards, margin, y, ytdCardWidth, cardHeight, cardGap, 4);
    y += 35;

    // SECTION 3: PROYECTADO ANUAL ACUMULADO
    pdf.setTextColor(textColor);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t.annualProjections, margin, y);
    y += 10;

    // Projection Cards (4 in a row)
    const projectionCards = [
      { 
        label: t.entradasProyectadas, 
        value: this.formatCurrency(data.annualProjections.entradasProyectadas, data.locale, data.currency),
        color: secondaryColor 
      },
      { 
        label: t.salidasProyectadas, 
        value: this.formatCurrency(data.annualProjections.salidasProyectadas, data.locale, data.currency),
        color: dangerColor 
      },
      { 
        label: t.flujoNetoProyectado, 
        value: this.formatCurrency(data.annualProjections.flujoNetoProyectado, data.locale, data.currency),
        color: data.annualProjections.flujoNetoProyectado >= 0 ? successColor : dangerColor 
      },
      { 
        label: t.generacionPromProyectada, 
        value: this.formatCurrency(data.annualProjections.generacionPromProyectada, data.locale, data.currency),
        color: '#9333ea' 
      }
    ];

    this.drawCardSection(pdf, projectionCards, margin, y, ytdCardWidth, cardHeight, cardGap, 4);
    y += 40;

    // Add page break before the monthly performance table
    pdf.addPage();
    y = 20;
    
    // ENHANCED MONTHLY PERFORMANCE TABLE
    pdf.setTextColor(textColor);
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t.monthlyPerformance, margin, y);
    y += 10;

    // Table headers with enhanced columns
    const tableY = y;
    const colWidths = [24, 20, 20, 20, 20, 18, 16, 12]; // Period, Inicial, Entradas, Salidas, Final, Generación, Growth, Status
    const headers = [
      t.periodo, 
      'Inicial', 
      t.entradas, 
      t.salidas, 
      'Final', 
      'Gen.', 
      t.crecimiento, 
      t.status
    ];
    
    // Header background
    pdf.setFillColor(248, 250, 252);
    pdf.rect(margin, tableY, colWidths.reduce((a, b) => a + b, 0), 8, 'F');
    
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(55, 65, 81);
    
    let x = margin;
    headers.forEach((header, i) => {
      pdf.text(header, x + colWidths[i]/2, tableY + 5, { align: 'center' });
      x += colWidths[i];
    });

    // Enhanced table rows with more data
    y = tableY + 12;
    pdf.setFont('helvetica', 'normal');
    
    const maxRows = Math.min(data.periods.length, 12);
    
    for (let i = 0; i < maxRows; i++) {
      // Check for page break
      if (y > pageHeight - 60) {
        pdf.addPage();
        y = 20;
      }
      
      // Alternate row background
      if (i % 2 === 1) {
        pdf.setFillColor(249, 250, 251);
        pdf.rect(margin, y - 2, colWidths.reduce((a, b) => a + b, 0), 7, 'F');
      }
      
      // Highlight current period row
      if (data.periods[i] === data.currentPeriod) {
        pdf.setFillColor(219, 234, 254); // Light blue
        pdf.rect(margin, y - 2, colWidths.reduce((a, b) => a + b, 0), 7, 'F');
      }
      
      const period = data.periods[i];
      const inflow = data.totalInflows?.values[i] || 0;
      const outflow = Math.abs(data.totalOutflows?.values[i] || 0);
      const net = data.netCashFlow?.values[i] || 0;
      const initialBal = data.initialBalance?.values[i] || 0;
      const finalBal = data.finalBalance?.values[i] || 0;
      const generation = data.monthlyGeneration?.values[i] || 0;
      
      // Calculate growth
      let growth = 0;
      if (i > 0) {
        const previousGen = data.monthlyGeneration?.values[i-1] || 0;
        if (previousGen !== 0) {
          growth = ((generation - previousGen) / Math.abs(previousGen)) * 100;
        }
      }
      
      // Determine status
      let status = '●';
      let statusColor = successColor;
      if (generation < 0) {
        status = '●';
        statusColor = dangerColor;
      } else if (finalBal < initialBal) { // Balance decreased
        status = '●';
        statusColor = warningColor;
      }
      
      const rowData = [
        { 
          text: period.length > 8 ? period.substring(0, 8) + '...' : period, 
          color: data.periods[i] === data.currentPeriod ? primaryColor : textColor,
          bold: data.periods[i] === data.currentPeriod
        },
        { text: this.formatCurrency(initialBal, data.locale, data.currency).replace('ARS', '').replace('$', ''), color: '#6366f1' },
        { text: this.formatCurrency(inflow, data.locale, data.currency).replace('ARS', '').replace('$', ''), color: secondaryColor },
        { text: this.formatCurrency(outflow, data.locale, data.currency).replace('ARS', '').replace('$', ''), color: dangerColor },
        { text: this.formatCurrency(finalBal, data.locale, data.currency).replace('ARS', '').replace('$', ''), color: finalBal >= 0 ? successColor : dangerColor },
        { text: this.formatCurrency(generation, data.locale, data.currency).replace('ARS', '').replace('$', ''), color: generation >= 0 ? successColor : dangerColor },
        { 
          text: i === 0 ? '-' : `${growth > 0 ? '+' : ''}${growth.toFixed(1)}%`, 
          color: growth > 0 ? successColor : (growth < 0 ? dangerColor : textColor) 
        },
        { text: status, color: statusColor }
      ];

      x = margin;
      rowData.forEach((cell, j) => {
        const colorRgb = this.hexToRgb(cell.color);
        pdf.setTextColor(colorRgb.r, colorRgb.g, colorRgb.b);
        if (cell.bold) {
          pdf.setFont('helvetica', 'bold');
        }
        pdf.text(cell.text, x + colWidths[j]/2, y + 2, { align: 'center' });
        if (cell.bold) {
          pdf.setFont('helvetica', 'normal');
        }
        x += colWidths[j];
      });
      
      y += 7;
    }

    y += 10;

    // Check for new page BEFORE drawing charts (charts need ~400px total space + 40px footer)
    const chartsNeededSpace = 400; // Total space needed for all charts (3 full-width taller charts stacked)
    const footerReservedSpace = 40;  // Space reserved for footer
    
    if (y + chartsNeededSpace > pageHeight - footerReservedSpace) {
      pdf.addPage();
      y = 20;
    }

    // CHARTS SECTION
    await this.addChartsSection(pdf, data, t, margin, y, pageWidth, pageHeight, textColor, primaryColor, secondaryColor, successColor, dangerColor, gridColor, accentColor);
    
    // Add page break after charts
    pdf.addPage();
    y = 20; // Reset y position for next page

    // FOOTER on all pages
    const totalPages = pdf.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      
      // Footer line
      pdf.setDrawColor(226, 232, 240);
      pdf.line(margin, pageHeight - 20, pageWidth - margin, pageHeight - 20);
      
      // Footer text
      pdf.setFontSize(8);
      pdf.setTextColor(107, 114, 128);
      pdf.text(
        `${t.confidential} - ${t.generatedBy} ${data.organizationName}`, 
        margin, 
        pageHeight - 12
      );
      pdf.text(
        `${t.page} ${i} ${t.of} ${totalPages}`, 
        pageWidth - margin, 
        pageHeight - 12, 
        { align: 'right' }
      );
      
      // Generation timestamp
      pdf.text(
        new Date(data.generatedAt).toLocaleDateString(data.locale), 
        pageWidth/2, 
        pageHeight - 12, 
        { align: 'center' }
      );
    }

    // Return as buffer
    const pdfOutput = pdf.output('arraybuffer');
    return Buffer.from(pdfOutput);
  }

  private async addChartsSection(
    pdf: jsPDF, 
    data: ComprehensiveExportData, 
    t: any, 
    margin: number, 
    startY: number,
    pageWidth: number,
    pageHeight: number,
    textColor: string,
    primaryColor: string,
    secondaryColor: string,
    successColor: string,
    dangerColor: string,
    gridColor: string,
    accentColor: string
  ) {
    let y = startY;
    const chartWidth = pageWidth - margin * 2; // Full width charts
    const chartHeight = 120; // Much taller for better visibility and appreciation
    
    // Chart 1: Cash Flow Growth Analysis (Combined Bar+Line Chart)
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(55, 65, 81);
    pdf.text(t.growthAnalysis, margin, y);
    y += 8;
    
    await this.drawCombinedBarLineChart(
      pdf,
      data,
      margin,
      y,
      chartWidth,
      chartHeight,
      textColor,
      gridColor,
      data.currency,
      data.locale,
      t.growthAnalysis
    );
    
    y += chartHeight + 25;
    
    // Add page break before Balance Trends chart
    pdf.addPage();
    y = 20; // Reset y position for new page
    
    // Chart 2: Balance Trends and Forecast (Combined Bar+Line Chart)
    pdf.text(t.balanceTrends, margin, y);
    y += 8;
    
    await this.drawCombinedBarLineChart(
      pdf,
      data,
      margin,
      y,
      chartWidth,
      chartHeight,
      textColor,
      gridColor,
      data.currency,
      data.locale,
      t.balanceTrends
    );
    
    y += chartHeight + 25;
    
    // Check if we need a new page for the data table
    if (y + 100 > pageHeight - 40) {
      pdf.addPage();
      y = 20;
    }
    
    // Chart 3: Monthly Performance Data Table (existing bar chart converted to table)
    pdf.text(t.monthlyPerformance, margin, y);
    y += 8;
    
    this.drawProfessionalBarChart(
      pdf, 
      [
        { label: data.locale?.startsWith('es') ? 'Entradas' : 'Inflows', values: data.totalInflows?.values || [], color: '#10B981' }, // Emerald green for consistency
        { label: data.locale?.startsWith('es') ? 'Salidas' : 'Outflows', values: (data.totalOutflows?.values || []).map((v: number) => Math.abs(v)), color: '#EF4444' }, // Red for outflows
        { label: data.locale?.startsWith('es') ? 'Generación' : 'Generation', values: data.monthlyGeneration?.values || [], color: '#06B6D4' } // Cyan for generation
      ],
      data.periods,
      margin,
      y,
      pageWidth - margin * 2,
      chartHeight,
      textColor,
      gridColor,
      data.currency,
      data.locale
    );
  }

  // Gradient helper functions for professional charts
  private createGradientFill(pdf: jsPDF, x: number, y: number, width: number, height: number, colorStart: string, colorEnd: string, vertical: boolean = true) {
    const startRgb = this.hexToRgb(colorStart);
    const endRgb = this.hexToRgb(colorEnd);
    
    const steps = vertical ? Math.ceil(height) : Math.ceil(width);
    const stepSize = vertical ? height / steps : width / steps;
    
    for (let i = 0; i < steps; i++) {
      const ratio = i / steps;
      const r = Math.round(startRgb.r + (endRgb.r - startRgb.r) * ratio);
      const g = Math.round(startRgb.g + (endRgb.g - startRgb.g) * ratio);
      const b = Math.round(startRgb.b + (endRgb.b - startRgb.b) * ratio);
      
      pdf.setFillColor(r, g, b);
      
      if (vertical) {
        pdf.rect(x, y + i * stepSize, width, stepSize + 0.1, 'F');
      } else {
        pdf.rect(x + i * stepSize, y, stepSize + 0.1, height, 'F');
      }
    }
  }

  private drawShadow(pdf: jsPDF, x: number, y: number, width: number, height: number, shadowOffset: number = 1) {
    pdf.setFillColor(200, 200, 200);
    pdf.rect(x + shadowOffset, y + shadowOffset, width, height, 'F');
  }

  private drawRoundedRect(pdf: jsPDF, x: number, y: number, width: number, height: number, radius: number, fillColor: string, strokeColor?: string) {
    // Simplified rounded rectangle using regular rectangles
    const colorRgb = this.hexToRgb(fillColor);
    pdf.setFillColor(colorRgb.r, colorRgb.g, colorRgb.b);
    
    if (strokeColor && strokeColor !== 'transparent') {
      const strokeRgb = this.hexToRgb(strokeColor);
      pdf.setDrawColor(strokeRgb.r, strokeRgb.g, strokeRgb.b);
      pdf.rect(x, y, width, height, 'FD');
    } else {
      pdf.rect(x, y, width, height, 'F');
    }
  }

  private drawSmoothCurve(pdf: jsPDF, points: Array<{x: number, y: number}>, strokeColor: string, lineWidth: number = 2) {
    if (points.length < 2) return;
    
    const colorRgb = this.hexToRgb(strokeColor);
    pdf.setDrawColor(colorRgb.r, colorRgb.g, colorRgb.b);
    pdf.setLineWidth(lineWidth);
    
    // Draw smooth lines by connecting points with improved interpolation
    for (let i = 1; i < points.length; i++) {
      pdf.line(points[i-1].x, points[i-1].y, points[i].x, points[i].y);
    }
  }

  private drawGridLines(pdf: jsPDF, x: number, y: number, width: number, height: number, gridColor: string, steps: number = 5) {
    const gridColorRgb = this.hexToRgb(gridColor);
    pdf.setDrawColor(gridColorRgb.r, gridColorRgb.g, gridColorRgb.b);
    pdf.setLineWidth(0.3);
    
    // Horizontal grid lines
    for (let i = 1; i < steps; i++) {
      const lineY = y + (height / steps) * i;
      pdf.line(x, lineY, x + width, lineY);
    }
    
    // Vertical grid lines (fewer lines)
    const verticalSteps = Math.min(6, steps);
    for (let i = 1; i < verticalSteps; i++) {
      const lineX = x + (width / verticalSteps) * i;
      pdf.line(lineX, y, lineX, y + height);
    }
  }

  private drawAxisLabels(
    pdf: jsPDF, 
    x: number, 
    y: number, 
    width: number, 
    height: number,
    values: number[],
    labels: string[],
    currency: string,
    locale: string,
    textColor: string
  ) {
    const textColorRgb = this.hexToRgb(textColor);
    pdf.setTextColor(textColorRgb.r, textColorRgb.g, textColorRgb.b);
    pdf.setFontSize(7);
    pdf.setFont('helvetica', 'normal');
    
    // Y-axis labels (values)
    const maxVal = Math.max(...values.map(v => Math.abs(v)));
    const minVal = Math.min(...values);
    const range = maxVal - minVal || 1;
    
    // Draw Y-axis labels aligned with grid lines (5 steps total including borders)
    for (let i = 0; i <= 4; i++) {
      const value = minVal + (range / 4) * i;
      // Align exactly with grid lines - use same calculation as drawGridLines
      const labelY = y + height - (i * height / 4); // Start from bottom, go up
      const formattedValue = this.formatCurrency(value, locale, currency).replace('ARS', '').replace('USD', '');
      pdf.text(formattedValue, x - 5, labelY + 2, { align: 'right' }); // +2 for better vertical centering
    }
    
    // X-axis labels (periods) - align exactly with data points
    const displayLabels = labels.slice(-6); // Last 6 periods
    const displayValues = values.slice(-6); // Match the same data used for points
    for (let i = 0; i < Math.min(displayLabels.length, 6); i++) {
      // Use EXACT same calculation as data points for perfect alignment
      const labelX = x + 8 + i * ((width - 16) / Math.max(displayValues.length - 1, 1)); // Match chartX calculation
      
      // Format period label to be shorter and cleaner
      let periodLabel = displayLabels[i];
      
      // Convert "julio 2025" to "Jul 25", "agosto 2025" to "Ago 25", etc.
      if (periodLabel.includes(' 2025')) {
        const monthMap: { [key: string]: string } = {
          'julio': 'Jul', 'agosto': 'Ago', 'septiembre': 'Sep',
          'octubre': 'Oct', 'noviembre': 'Nov', 'diciembre': 'Dic',
          'enero': 'Ene', 'febrero': 'Feb', 'marzo': 'Mar',
          'abril': 'Abr', 'mayo': 'May', 'junio': 'Jun'
        };
        
        for (const [full, short] of Object.entries(monthMap)) {
          if (periodLabel.toLowerCase().includes(full)) {
            periodLabel = `${short} 25`;
            break;
          }
        }
      }
      
      // If still too long, truncate
      if (periodLabel.length > 6) {
        periodLabel = periodLabel.substring(0, 6);
      }
      
      pdf.text(periodLabel, labelX, y + height + 10, { align: 'center', angle: 0 });
    }
  }

  private drawLegend(
    pdf: jsPDF,
    x: number,
    y: number,
    series: Array<{label: string, color: string}>,
    textColor: string
  ) {
    const textColorRgb = this.hexToRgb(textColor);
    pdf.setTextColor(textColorRgb.r, textColorRgb.g, textColorRgb.b);
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');
    
    let currentX = x;
    for (let i = 0; i < series.length; i++) {
      // Color indicator
      const colorRgb = this.hexToRgb(series[i].color);
      pdf.setFillColor(colorRgb.r, colorRgb.g, colorRgb.b);
      pdf.rect(currentX, y - 2, 6, 4, 'F');
      
      // Label
      pdf.text(series[i].label, currentX + 8, y + 1);
      currentX += series[i].label.length * 2 + 20; // Approximate width + spacing
    }
  }

  private drawDataLabels(
    pdf: jsPDF,
    values: number[],
    labels: string[],
    x: number,
    y: number,
    width: number,
    height: number,
    currency: string,
    locale: string,
    color: string
  ) {
    const colorRgb = this.hexToRgb(color);
    pdf.setTextColor(colorRgb.r, colorRgb.g, colorRgb.b);
    pdf.setFontSize(6);
    pdf.setFont('helvetica', 'bold');
    
    const maxVal = Math.max(...values.map(v => Math.abs(v)));
    const minVal = Math.min(...values);
    const range = maxVal - minVal || 1;
    
    for (let i = 0; i < Math.min(values.length, 6); i++) {
      const px = x + i * (width / Math.max(Math.min(values.length - 1, 5), 1));
      const py = y + height - ((values[i] - minVal) / range) * height;
      const value = this.formatCurrency(values[i], locale, currency).replace('ARS', '').replace('USD', '');
      
      // Position label further above the point to prevent overlap with line
      // Also make font smaller and use better positioning
      pdf.setFontSize(5);
      pdf.text(value, px, py - 8, { align: 'center' });
    }
  }

  private drawProfessionalLineChart(
    pdf: jsPDF, 
    values: number[], 
    labels: string[], 
    x: number, 
    y: number, 
    width: number, 
    height: number,
    lineColor: string,
    pointColor: string,
    gridColor: string,
    textColor: string,
    currency: string,
    locale: string
  ) {
    if (values.length < 2) return;
    
    // Chart area with padding
    const chartPadding = 8;
    const chartX = x + chartPadding;
    const chartY = y + chartPadding;
    const chartWidth = width - chartPadding * 2;
    const chartHeight = height - chartPadding * 2;
    
    // Background
    pdf.setFillColor(252, 252, 253);
    pdf.rect(x, y, width, height, 'F');
    
    // Professional border
    pdf.setDrawColor(203, 213, 225);
    pdf.setLineWidth(0.8);
    pdf.rect(x, y, width, height, 'S');
    
    // Draw grid lines
    this.drawGridLines(pdf, chartX, chartY, chartWidth, chartHeight, gridColor);
    
    // Draw axis labels
    this.drawAxisLabels(pdf, chartX, chartY, chartWidth, chartHeight, values, labels, currency, locale, textColor);
    
    // Calculate points
    const displayValues = values.slice(-6); // Last 6 values
    const maxVal = Math.max(...displayValues.map(v => Math.abs(v)));
    const minVal = Math.min(...displayValues);
    const range = maxVal - minVal || 1;
    
    // Calculate line points
    const points: {x: number, y: number}[] = [];
    for (let i = 0; i < displayValues.length; i++) {
      const px = chartX + i * (chartWidth / Math.max(displayValues.length - 1, 1));
      const py = chartY + chartHeight - ((displayValues[i] - minVal) / range) * chartHeight;
      points.push({x: px, y: py});
    }
    
    // Draw proper area fill under the curve - NO BLACK
    if (points.length > 1) {
      // Use light version of series color for fill
      let fillColor = '#34D399'; // Light emerald for Growth Analysis
      
      if (lineColor === '#8B5CF6') {
        fillColor = '#A78BFA'; // Light purple for Balance Trends
      } else if (lineColor === '#10B981') {
        fillColor = '#34D399'; // Light emerald for Growth Analysis
      } else if (lineColor === '#06B6D4') {
        fillColor = '#67E8F9'; // Light cyan
      }
      
      const fillRgb = this.hexToRgb(fillColor);
      pdf.setFillColor(fillRgb.r, fillRgb.g, fillRgb.b); // No opacity to avoid black
      
      // Create proper area under curve by drawing from each point to bottom
      const chartBottom = chartY + chartHeight;
      
      // Start drawing the filled area
      for (let i = 0; i < points.length - 1; i++) {
        const x1 = points[i].x;
        const y1 = points[i].y;
        const x2 = points[i + 1].x;
        const y2 = points[i + 1].y;
        
        // Create trapezoid from chart bottom to line
        const trapezoidHeight = Math.max(chartBottom - y1, chartBottom - y2);
        if (trapezoidHeight > 0) {
          // Draw filled area from bottom to line points
          pdf.rect(x1, chartBottom - trapezoidHeight, x2 - x1, trapezoidHeight, 'F');
        }
      }
    }
    
    // Draw smooth curved line instead of straight lines
    this.drawSmoothCurve(pdf, points, lineColor, 3);
    
    // Draw enhanced points
    const pointColorRgb = this.hexToRgb(pointColor);
    pdf.setFillColor(pointColorRgb.r, pointColorRgb.g, pointColorRgb.b);
    pdf.setDrawColor(255, 255, 255); // White border
    pdf.setLineWidth(1);
    
    for (const point of points) {
      pdf.circle(point.x, point.y, 2, 'FD'); // Fill and Draw (with border)
    }
    
    // Draw data labels on points
    this.drawDataLabels(pdf, displayValues, labels.slice(-6), chartX, chartY, chartWidth, chartHeight, currency, locale, textColor);
    
    // Add simple legend to show what the line represents
    const lineColorRgb = this.hexToRgb(lineColor);
    pdf.setFontSize(6);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(lineColorRgb.r, lineColorRgb.g, lineColorRgb.b);
    
    // Draw small line sample and label in top-right corner
    const legendX = x + width - 40;
    const legendY = y + 15;
    
    // Draw line sample
    pdf.setDrawColor(lineColorRgb.r, lineColorRgb.g, lineColorRgb.b);
    pdf.setLineWidth(2);
    pdf.line(legendX, legendY, legendX + 8, legendY);
    
    // Add text label
    const seriesName = lineColor === '#10B981' ? 'Crecimiento' : lineColor === '#8B5CF6' ? 'Balance' : 'Flujo';
    pdf.text(seriesName, legendX + 10, legendY + 1);
    
    // Add trend indicators (arrows)
    if (displayValues.length >= 2) {
      const trend = displayValues[displayValues.length-1] - displayValues[displayValues.length-2];
      const trendColor = trend >= 0 ? '#10b981' : '#ef4444';
      const trendColorRgb = this.hexToRgb(trendColor);
      pdf.setTextColor(trendColorRgb.r, trendColorRgb.g, trendColorRgb.b);
      pdf.setFontSize(12);
      const arrow = trend >= 0 ? '↗' : '↘';
      pdf.text(arrow, x + width - 15, y + 15);
    }
  }

  private async generateChartHTML(
    data: ComprehensiveExportData,
    title: string,
    currency: string,
    locale: string
  ): Promise<string> {
    // Use actual period names from data, showing 12 periods centered on current period
    const totalPeriods = data.periods.length;
    const currentIndex = data.currentPeriodIndex;
    
    // Calculate 12-period window centered on current period
    const startIndex = Math.max(0, Math.min(currentIndex - 5, totalPeriods - 12));
    const endIndex = Math.min(totalPeriods, startIndex + 12);
    
    const periods: string[] = [];
    const inflows: number[] = [];
    const outflows: number[] = [];
    const balances: number[] = [];
    
    // Extract actual period names and corresponding data
    for (let i = startIndex; i < endIndex; i++) {
      // Extract just the month part from period names like "julio 2025" -> "Jul"
      let periodLabel = data.periods[i] || '';
      if (locale?.startsWith('es')) {
        // Convert Spanish month names to short form
        periodLabel = periodLabel
          .replace('enero', 'Ene')
          .replace('febrero', 'Feb')
          .replace('marzo', 'Mar')
          .replace('abril', 'Abr')
          .replace('mayo', 'May')
          .replace('junio', 'Jun')
          .replace('julio', 'Jul')
          .replace('agosto', 'Ago')
          .replace('septiembre', 'Sep')
          .replace('octubre', 'Oct')
          .replace('noviembre', 'Nov')
          .replace('diciembre', 'Dic');
        
        // Extract just the month part (first 3 chars)
        periodLabel = periodLabel.split(' ')[0];
      } else {
        // English month names
        periodLabel = periodLabel
          .replace('January', 'Jan')
          .replace('February', 'Feb')
          .replace('March', 'Mar')
          .replace('April', 'Apr')
          .replace('May', 'May')
          .replace('June', 'Jun')
          .replace('July', 'Jul')
          .replace('August', 'Aug')
          .replace('September', 'Sep')
          .replace('October', 'Oct')
          .replace('November', 'Nov')
          .replace('December', 'Dec');
        
        // Extract just the month part (first 3 chars)
        periodLabel = periodLabel.split(' ')[0];
      }
      
      periods.push(periodLabel);
      inflows.push(data.totalInflows?.values[i] || 0);
      outflows.push(Math.abs(data.totalOutflows?.values[i] || 0));
      balances.push(data.finalBalance?.values[i] || 0);
    }

    // Create chart data with actual vs forecast distinction
    const actualInflowsData: number[] = [];
    const forecastInflowsData: number[] = [];
    const actualOutflowsData: number[] = [];
    const forecastOutflowsData: number[] = [];
    const actualBalancesData: number[] = [];
    const forecastBalancesData: number[] = [];
    
    // Split data based on actual vs forecast using configuration
    for (let i = 0; i < periods.length; i++) {
      const periodIndex = startIndex + i;
      const periodName = data.periods[periodIndex] || '';
      
      // Determine if period is actual based on configuration
      let isActual = periodIndex <= currentIndex; // Default fallback
      
      // First priority: Use periodMetadata if available (most reliable)
      if (data.periodMetadata && data.periods[periodIndex]) {
        const periodKey = data.periods[periodIndex];
        const metadata = data.periodMetadata[periodKey];
        if (metadata && typeof metadata.isActual === 'boolean') {
          isActual = metadata.isActual;
        }
      } else if (data.lastActualPeriodLabel) {
        // Fallback: Use lastActualPeriodLabel matching
        const lastActualIndex = data.periods.findIndex(p => 
          p.toLowerCase().includes(data.lastActualPeriodLabel!.toLowerCase()) ||
          data.lastActualPeriodLabel!.toLowerCase().includes(p.toLowerCase().split(' ')[0])
        );
        
        if (lastActualIndex >= 0) {
          isActual = periodIndex <= lastActualIndex;
        }
      }
      
      if (isActual) {
        actualInflowsData.push(inflows[i]);
        forecastInflowsData.push(NaN);
        actualOutflowsData.push(outflows[i]);
        forecastOutflowsData.push(NaN);
        actualBalancesData.push(balances[i]);
        forecastBalancesData.push(NaN);
      } else {
        actualInflowsData.push(NaN);
        forecastInflowsData.push(inflows[i]);
        actualOutflowsData.push(NaN);
        forecastOutflowsData.push(outflows[i]);
        actualBalancesData.push(NaN);
        forecastBalancesData.push(balances[i]);
      }
    }
    
    // Determine chart type based on title
    const isGrowthAnalysis = title.toLowerCase().includes('crecimiento') || title.toLowerCase().includes('growth');
    const isTrendAnalysis = title.toLowerCase().includes('tendencias') || title.toLowerCase().includes('trend');
    
    let chartData;
    let chartType = 'bar'; // default
    
    if (isTrendAnalysis) {
      // Area chart for "Tendencias de Balance Final y Pronóstico"
      chartType = 'line';
      chartData = {
        labels: periods,
        datasets: [
          {
            label: locale?.startsWith('es') ? 'Entradas Totales' : 'Total Inflows',
            data: [...actualInflowsData, ...forecastInflowsData].map((val, idx) => {
              // Combine actual and forecast data into one dataset
              return actualInflowsData[idx] || forecastInflowsData[idx] || null;
            }),
            type: 'line',
            backgroundColor: 'rgba(16, 185, 129, 0.3)',
            borderColor: 'transparent',
            borderWidth: 0,
            fill: 'origin',
            pointRadius: 0,
            pointHoverRadius: 0,
            order: 3
          },
          {
            label: locale?.startsWith('es') ? 'Salidas Totales' : 'Total Outflows',
            data: [...actualOutflowsData, ...forecastOutflowsData].map((val, idx) => {
              // Convert to negative values for outflows (below zero)
              const value = actualOutflowsData[idx] || forecastOutflowsData[idx] || null;
              return value !== null ? -Math.abs(value) : null;
            }),
            type: 'line',
            backgroundColor: 'rgba(239, 68, 68, 0.3)',
            borderColor: 'transparent',
            borderWidth: 0,
            fill: 'origin',
            pointRadius: 0,
            pointHoverRadius: 0,
            order: 3
          },
          {
            label: locale?.startsWith('es') ? 'Balance Final Real' : 'Actual Final Balance',
            data: actualBalancesData,
            type: 'line',
            borderColor: '#10B981',
            backgroundColor: 'transparent',
            borderWidth: 3,
            fill: false,
            pointBackgroundColor: '#10B981',
            pointBorderColor: '#FFFFFF',
            pointBorderWidth: 2,
            pointRadius: 6,
            order: 1,
            yAxisID: 'y1'
          },
          {
            label: locale?.startsWith('es') ? 'Pronóstico Balance Final' : 'Forecast Final Balance',
            data: forecastBalancesData,
            type: 'line',
            borderColor: '#3B82F6',
            backgroundColor: 'transparent',
            borderWidth: 3,
            borderDash: [8, 8],
            fill: false,
            pointBackgroundColor: '#3B82F6',
            pointBorderColor: '#FFFFFF',
            pointBorderWidth: 2,
            pointRadius: 6,
            order: 1,
            yAxisID: 'y1'
          },
          {
            label: locale?.startsWith('es') ? 'Línea de Tendencia' : 'Trend Line',
            data: periods.map(() => 0),
            type: 'line',
            borderColor: '#6B7280',
            backgroundColor: 'transparent',
            borderWidth: 1,
            fill: false,
            pointRadius: 0,
            pointHoverRadius: 0,
            order: 2
          }
        ]
      };
    } else {
      // Bar chart for "Análisis de Crecimiento del Cash Flow" and others
      chartType = 'bar';
      chartData = {
        labels: periods,
        datasets: [
          {
            label: locale?.startsWith('es') ? 'Ingresos (Real)' : 'Inflows (Actual)',
            data: actualInflowsData,
            backgroundColor: '#10B981',
            borderColor: '#10B981',
            borderWidth: 1,
            order: 2
          },
          {
            label: locale?.startsWith('es') ? 'Ingresos (Pronóstico)' : 'Inflows (Forecast)',
            data: forecastInflowsData,
            backgroundColor: 'rgba(16, 185, 129, 0.15)',
            borderColor: '#10B981',
            borderWidth: 2,
            borderDash: [3, 3],
            order: 2
          },
          {
            label: locale?.startsWith('es') ? 'Gastos (Real)' : 'Outflows (Actual)',  
            data: actualOutflowsData,
            backgroundColor: '#EF4444',
            borderColor: '#EF4444',
            borderWidth: 1,
            order: 2
          },
          {
            label: locale?.startsWith('es') ? 'Gastos (Pronóstico)' : 'Outflows (Forecast)',  
            data: forecastOutflowsData,
            backgroundColor: 'rgba(239, 68, 68, 0.15)',
            borderColor: '#EF4444',
            borderWidth: 2,
            borderDash: [3, 3],
            order: 2
          },
          {
            label: locale?.startsWith('es') ? 'Balance Final (Real)' : 'Final Balance (Actual)',
            data: actualBalancesData,
            type: 'line',
            borderColor: '#10B981',
            backgroundColor: 'transparent',
            borderWidth: 3,
            borderDash: [5, 5],
            pointBackgroundColor: '#10B981',
            pointBorderColor: '#FFFFFF',
            pointBorderWidth: 2,
            pointRadius: 6,
            order: 1,
            yAxisID: 'y1'
          },
          {
            label: locale?.startsWith('es') ? 'Balance Final (Pronóstico)' : 'Final Balance (Forecast)',
            data: forecastBalancesData,
            type: 'line',
            borderColor: '#10B981',
            backgroundColor: 'transparent',
            borderWidth: 3,
            borderDash: [5, 5],
            pointBackgroundColor: '#10B981',
            pointBorderColor: '#FFFFFF',
            pointBorderWidth: 2,
            pointRadius: 6,
            order: 1,
            yAxisID: 'y1'
          }
        ]
      };
    }

    return `
      <!DOCTYPE html>
      <html lang="${locale?.startsWith('es') ? 'es' : 'en'}">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${title}</title>
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
        <style>
          * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }
          
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: white;
            margin: 0;
            padding: 20px;
            width: 1200px;
            height: 700px;
            box-sizing: border-box;
          }
          
          .chart-container {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 8px;
            padding: 32px;
            box-sizing: border-box;
            border: 1px solid #e5e7eb;
          }
          
          .chart-title {
            font-size: 22px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 24px;
            text-align: center;
            letter-spacing: -0.025em;
          }
          
          #chartCanvas {
            width: 100% !important;
            height: 580px !important;
          }
          
          @media print {
            body {
              -webkit-print-color-adjust: exact;
              print-color-adjust: exact;
              background: white !important;
            }
            
            .chart-container {
              box-shadow: none;
              border: 1px solid #e2e8f0;
            }
          }
        </style>
      </head>
      <body>
        <div class="chart-container">
          <canvas id="chartCanvas"></canvas>
        </div>
        
        <script>
          const ctx = document.getElementById('chartCanvas').getContext('2d');
          
          const chartData = ${JSON.stringify(chartData)};
          
          const config = {
            type: '${chartType}',
            data: chartData,
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: false,
              plugins: {
                legend: {
                  display: true,
                  position: 'top',
                  labels: {
                    usePointStyle: true,
                    padding: 20,
                    font: {
                      size: 14,
                      weight: '500'
                    },
                    color: '#374151'
                  }
                },
                tooltip: {
                  enabled: false // Disable for PDF generation
                }
              },
              scales: {
                x: {
                  grid: {
                    display: true,
                    color: '#f3f4f6',
                    lineWidth: 1
                  },
                  ticks: {
                    font: {
                      size: 12,
                      weight: '500'
                    },
                    color: '#6b7280',
                    maxRotation: 0
                  },
                  border: {
                    display: true,
                    color: '#d1d5db'
                  }
                },
                y: {
                  position: 'left',
                  grid: {
                    display: true,
                    color: '#f3f4f6',
                    lineWidth: 1
                  },
                  ticks: {
                    font: {
                      size: 11,
                      weight: '500'
                    },
                    color: '#6b7280',
                    callback: function(value) {
                      const num = Number(value);
                      if (num >= 1000000) return '${currency === 'USD' ? '$' : currency}' + (num / 1000000).toFixed(1) + 'M';
                      if (num >= 1000) return '${currency === 'USD' ? '$' : currency}' + (num / 1000).toFixed(1) + 'K';
                      return '${currency === 'USD' ? '$' : currency}' + num.toFixed(0);
                    }
                  },
                  border: {
                    display: true,
                    color: '#d1d5db'
                  }
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  grid: {
                    drawOnChartArea: false // Don't draw grid lines for right axis
                  },
                  ticks: {
                    font: {
                      size: 11,
                      weight: '500'
                    },
                    color: '#6b7280',
                    callback: function(value) {
                      const num = Number(value);
                      if (num >= 1000000) return '${currency === 'USD' ? '$' : currency}' + (num / 1000000).toFixed(1) + 'M';
                      if (num >= 1000) return '${currency === 'USD' ? '$' : currency}' + (num / 1000).toFixed(1) + 'K';
                      return '${currency === 'USD' ? '$' : currency}' + num.toFixed(0);
                    }
                  },
                  border: {
                    display: true,
                    color: '#d1d5db'
                  }
                }
              },
              elements: {
                bar: {
                  borderRadius: 4,
                  borderSkipped: false
                },
                point: {
                  borderWidth: 3,
                  radius: 6,
                  hoverRadius: 8
                }
              }
            }
          };
          
          const chart = new Chart(ctx, config);
          
          // Signal that chart is ready for screenshot
          window.chartReady = true;
        </script>
      </body>
      </html>
    `;
  }

  private async generateSVGChart(
    data: ComprehensiveExportData,
    title: string,
    currency: string,
    locale: string,
    width: number = 600,
    height: number = 300
  ): Promise<string> {
    // Use actual period names from data, showing 12 periods centered on current period
    const totalPeriods = data.periods.length;
    const currentIndex = data.currentPeriodIndex;
    
    // Calculate 12-period window centered on current period
    const startIndex = Math.max(0, Math.min(currentIndex - 5, totalPeriods - 12));
    const endIndex = Math.min(totalPeriods, startIndex + 12);
    
    const periods: string[] = [];
    const inflows: number[] = [];
    const outflows: number[] = [];
    const balances: number[] = [];
    
    // Extract actual period names and corresponding data
    for (let i = startIndex; i < endIndex; i++) {
      // Extract just the month part from period names like "julio 2025" -> "Jul"
      let periodLabel = data.periods[i] || '';
      if (locale?.startsWith('es')) {
        // Convert Spanish month names to short form
        periodLabel = periodLabel
          .replace('enero', 'Ene')
          .replace('febrero', 'Feb')
          .replace('marzo', 'Mar')
          .replace('abril', 'Abr')
          .replace('mayo', 'May')
          .replace('junio', 'Jun')
          .replace('julio', 'Jul')
          .replace('agosto', 'Ago')
          .replace('septiembre', 'Sep')
          .replace('octubre', 'Oct')
          .replace('noviembre', 'Nov')
          .replace('diciembre', 'Dic');
        
        // Extract just the month part (first 3 chars)
        periodLabel = periodLabel.split(' ')[0];
      } else {
        // English month names
        periodLabel = periodLabel
          .replace('January', 'Jan')
          .replace('February', 'Feb')
          .replace('March', 'Mar')
          .replace('April', 'Apr')
          .replace('May', 'May')
          .replace('June', 'Jun')
          .replace('July', 'Jul')
          .replace('August', 'Aug')
          .replace('September', 'Sep')
          .replace('October', 'Oct')
          .replace('November', 'Nov')
          .replace('December', 'Dec');
        
        // Extract just the month part (first 3 chars)
        periodLabel = periodLabel.split(' ')[0];
      }
      
      periods.push(periodLabel);
      inflows.push(data.totalInflows?.values[i] || 0);
      outflows.push(Math.abs(data.totalOutflows?.values[i] || 0));
      balances.push(data.finalBalance?.values[i] || 0);
    }

    // Calculate dimensions and scales
    const padding = { top: 60, right: 40, bottom: 60, left: 60 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;
    
    const allValues = [...inflows, ...outflows, ...balances.map(v => Math.abs(v))];
    const maxVal = Math.max(...allValues) || 1;
    const barWidth = chartWidth / (periods.length * 2.5); // Space for two bars per month
    
    // SVG generation
    let svg = `
      <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <style>
            .chart-title { font: bold 16px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; fill: #1f2937; text-anchor: middle; }
            .axis-label { font: 11px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; fill: #6b7280; text-anchor: middle; }
            .legend-text { font: 12px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; fill: #374151; }
            .grid-line { stroke: #f3f4f6; stroke-width: 1; }
          </style>
        </defs>
        
        <!-- Background -->
        <rect width="${width}" height="${height}" fill="white"/>
        
        <!-- Title -->
        <text x="${width/2}" y="30" class="chart-title">${title}</text>
        
        <!-- Legend -->
        <g transform="translate(${width/2 - 200}, 50)">
          <rect x="0" y="0" width="12" height="8" fill="#10B981"/>
          <text x="16" y="7" class="legend-text">${locale?.startsWith('es') ? 'Real' : 'Actual'}</text>
          
          <rect x="60" y="0" width="12" height="8" fill="rgba(16, 185, 129, 0.15)" stroke="#10B981" stroke-width="1" stroke-dasharray="2,2"/>
          <text x="76" y="7" class="legend-text">${locale?.startsWith('es') ? 'Pronóstico' : 'Forecast'}</text>
          
          <rect x="160" y="0" width="12" height="8" fill="#EF4444"/>
          <text x="176" y="7" class="legend-text">${locale?.startsWith('es') ? 'Gastos' : 'Outflows'}</text>
          
          <line x1="240" y1="4" x2="260" y2="4" stroke="#10B981" stroke-width="2"/>
          <circle cx="250" cy="4" r="3" fill="#10B981" stroke="white" stroke-width="1"/>
          <text x="264" y="7" class="legend-text">${locale?.startsWith('es') ? 'Balance' : 'Balance'}</text>
        </g>
        
        <!-- Chart area -->
        <g transform="translate(${padding.left}, ${padding.top})">
          <!-- Grid lines -->
    `;
    
    // Add horizontal grid lines
    for (let i = 0; i <= 5; i++) {
      const y = (chartHeight / 5) * i;
      const value = maxVal - (maxVal / 5) * i;
      svg += `<line x1="0" y1="${y}" x2="${chartWidth}" y2="${y}" class="grid-line"/>`;
      
      // Y-axis labels
      let label = '';
      if (value >= 1000000) {
        label = `${currency}${(value / 1000000).toFixed(1)}M`;
      } else if (value >= 1000) {
        label = `${currency}${(value / 1000).toFixed(1)}K`;
      } else {
        label = `${currency}${value.toFixed(0)}`;
      }
      svg += `<text x="-10" y="${y + 4}" class="axis-label" text-anchor="end">${label}</text>`;
    }
    
    // Add bars and line points with actual vs forecast distinction
    const actualLinePoints: string[] = [];
    const forecastLinePoints: string[] = [];
    
    for (let i = 0; i < periods.length; i++) {
      const x = (chartWidth / periods.length) * i + (chartWidth / periods.length) * 0.2;
      const periodIndex = startIndex + i;
      const periodName = data.periods[periodIndex] || '';
      
      // Determine if period is actual based on configuration
      let isActual = periodIndex <= currentIndex; // Default fallback
      
      // First priority: Use periodMetadata if available (most reliable)
      if (data.periodMetadata && data.periods[periodIndex]) {
        const periodKey = data.periods[periodIndex];
        const metadata = data.periodMetadata[periodKey];
        if (metadata && typeof metadata.isActual === 'boolean') {
          isActual = metadata.isActual;
        }
      } else if (data.lastActualPeriodLabel) {
        // Fallback: Use lastActualPeriodLabel matching
        const lastActualIndex = data.periods.findIndex(p => 
          p.toLowerCase().includes(data.lastActualPeriodLabel!.toLowerCase()) ||
          data.lastActualPeriodLabel!.toLowerCase().includes(p.toLowerCase().split(' ')[0])
        );
        
        if (lastActualIndex >= 0) {
          isActual = periodIndex <= lastActualIndex;
        }
      }
      
      // Determine styling based on actual vs forecast
      const inflowColor = isActual ? '#10B981' : 'rgba(16, 185, 129, 0.15)';
      const outflowColor = isActual ? '#EF4444' : 'rgba(239, 68, 68, 0.15)';
      const strokeDash = isActual ? '' : 'stroke-dasharray="3,3"';
      
      // Inflow bar (green/light green)
      const inflowHeight = (inflows[i] / maxVal) * chartHeight;
      const inflowY = chartHeight - inflowHeight;
      svg += `<rect x="${x}" y="${inflowY}" width="${barWidth}" height="${inflowHeight}" fill="${inflowColor}" ${strokeDash} rx="2"/>`;
      
      // Outflow bar (red/light red)
      const outflowHeight = (outflows[i] / maxVal) * chartHeight;
      const outflowY = chartHeight - outflowHeight;
      svg += `<rect x="${x + barWidth + 4}" y="${outflowY}" width="${barWidth}" height="${outflowHeight}" fill="${outflowColor}" ${strokeDash} rx="2"/>`;
      
      // Balance line points (separate actual and forecast)
      const balanceY = chartHeight - (Math.abs(balances[i]) / maxVal) * chartHeight;
      const pointX = x + barWidth + 2;
      
      if (isActual) {
        actualLinePoints.push(`${pointX},${balanceY}`);
      } else {
        forecastLinePoints.push(`${pointX},${balanceY}`);
      }
      
      // Month label
      svg += `<text x="${x + barWidth}" y="${chartHeight + 20}" class="axis-label">${periods[i]}</text>`;
    }
    
    // Draw actual balance line (solid)
    if (actualLinePoints.length > 1) {
      svg += `<polyline points="${actualLinePoints.join(' ')}" fill="none" stroke="#10B981" stroke-width="2" stroke-dasharray="5,5"/>`;
      
      // Add actual line points
      actualLinePoints.forEach(point => {
        const [x, y] = point.split(',').map(Number);
        svg += `<circle cx="${x}" cy="${y}" r="3" fill="#10B981" stroke="white" stroke-width="1"/>`;
      });
    }
    
    // Draw forecast balance line (dashed)
    if (forecastLinePoints.length > 1) {
      svg += `<polyline points="${forecastLinePoints.join(' ')}" fill="none" stroke="#10B981" stroke-width="2" stroke-dasharray="4,4"/>`;
      
      // Add forecast line points
      forecastLinePoints.forEach(point => {
        const [x, y] = point.split(',').map(Number);
        svg += `<circle cx="${x}" cy="${y}" r="3" fill="#10B981" stroke="white" stroke-width="1"/>`;
      });
    }
    
    // Connect actual and forecast lines if both exist
    if (actualLinePoints.length > 0 && forecastLinePoints.length > 0) {
      const lastActual = actualLinePoints[actualLinePoints.length - 1];
      const firstForecast = forecastLinePoints[0];
      svg += `<line x1="${lastActual.split(',')[0]}" y1="${lastActual.split(',')[1]}" x2="${firstForecast.split(',')[0]}" y2="${firstForecast.split(',')[1]}" stroke="#10B981" stroke-width="2" stroke-dasharray="2,2"/>`;
    }
    
    svg += `
        </g>
      </svg>
    `;
    
    // Debug: Save SVG to file for inspection
    if (process.env.NODE_ENV === 'development') {
      const fs = await import('fs');
      await fs.promises.writeFile('/tmp/chart-debug.svg', svg);
      console.log('🎨 SVG chart saved to /tmp/chart-debug.svg for inspection');
    }
    
    return svg;
  }


  private async drawCombinedBarLineChart(
    pdf: jsPDF,
    data: ComprehensiveExportData,
    x: number,
    y: number,
    width: number,
    height: number,
    textColor: string,
    gridColor: string,
    currency: string,
    locale: string,
    title: string
  ) {
    try {
      // Try SVG approach first (vector quality)
      const svgChart = await this.generateSVGChart(data, title, currency, locale, width * 2, height * 2);
      
      // Convert SVG to data URL and embed
      const svgDataUrl = `data:image/svg+xml;base64,${Buffer.from(svgChart).toString('base64')}`;
      
      // jsPDF doesn't support SVG directly, convert to PNG using canvas
      // For now, skip SVG and go directly to Puppeteer
      throw new Error('SVG embedding not supported by jsPDF, using Puppeteer instead');
      
      console.log('✅ SVG chart generated successfully');
      
    } catch (svgError) {
      console.error('❌ SVG chart generation failed:', svgError);
      
      // Fallback to text if chart generation fails
      pdf.setFillColor(252, 252, 253);
      pdf.rect(x, y, width, height, 'F');
      
      pdf.setDrawColor(203, 213, 225);
      pdf.setLineWidth(0.8);
      pdf.rect(x, y, width, height, 'S');
      
      pdf.setFontSize(11);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(55, 65, 81);
      pdf.text(title, x + 10, y + 12);
      
      pdf.setFontSize(9);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(107, 114, 128);
      pdf.text('Chart generation failed - check server logs', x + 10, y + height / 2);
    }
  }

  private drawCombinedChartLegend(pdf: jsPDF, x: number, y: number, textColor: string) {
    const textColorRgb = this.hexToRgb(textColor);
    pdf.setTextColor(textColorRgb.r, textColorRgb.g, textColorRgb.b);
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');

    const legendSpacing = 85; // Space between legend items
    
    // Ingresos (green bar)
    pdf.setFillColor(16, 185, 129); // Emerald
    pdf.rect(x, y, 10, 5, 'F');
    pdf.setDrawColor(16, 185, 129);
    pdf.rect(x, y, 10, 5, 'S');
    pdf.text('Ingresos', x + 14, y + 4);

    // Gastos (red bar)
    pdf.setFillColor(239, 68, 68); // Red
    pdf.rect(x + legendSpacing, y, 10, 5, 'F');
    pdf.setDrawColor(239, 68, 68);
    pdf.rect(x + legendSpacing, y, 10, 5, 'S');
    pdf.text('Gastos', x + legendSpacing + 14, y + 4);

    // Balance Final (dashed line with point)
    pdf.setDrawColor(16, 185, 129);
    pdf.setLineWidth(2);
    
    // Draw dashed line sample
    for (let i = 0; i < 4; i++) {
      if (i % 2 === 0) {
        pdf.line(x + legendSpacing * 2 + i * 3, y + 2.5, x + legendSpacing * 2 + i * 3 + 2, y + 2.5);
      }
    }
    
    // Draw point on line
    pdf.setFillColor(16, 185, 129);
    pdf.circle(x + legendSpacing * 2 + 6, y + 2.5, 2, 'F');
    
    pdf.text('Balance Final', x + legendSpacing * 2 + 16, y + 4);
  }

  private drawProfessionalBarChart(
    pdf: jsPDF,
    series: Array<{ label: string, values: number[], color: string }>,
    labels: string[],
    x: number,
    y: number,
    width: number,
    height: number,
    textColor: string,
    gridColor: string,
    currency: string,
    locale: string
  ) {
    // Chart area with padding for legend and labels
    const chartPadding = 8;
    const legendHeight = 15;
    const chartX = x + chartPadding;
    const chartY = y + chartPadding + legendHeight;
    const chartWidth = width - chartPadding * 2;
    const chartHeight = height - chartPadding * 2 - legendHeight - 10; // Space for x-axis labels
    
    // Background
    pdf.setFillColor(252, 252, 253);
    pdf.rect(x, y, width, height, 'F');
    
    // Professional border
    pdf.setDrawColor(203, 213, 225);
    pdf.setLineWidth(0.8);
    pdf.rect(x, y, width, height, 'S');
    
    // Draw legend at top
    this.drawLegend(pdf, chartX, y + chartPadding + 5, series, textColor);
    
    // Draw professional grid lines
    this.drawGridLines(pdf, chartX, chartY, chartWidth, chartHeight, gridColor, 5);
    
    // Calculate bar dimensions
    const displayLabels = labels.slice(-6);
    const barGroupWidth = chartWidth / displayLabels.length;
    const barWidth = (barGroupWidth * 0.8) / series.length; // 80% of group width, divided by series count
    const barSpacing = barGroupWidth * 0.1; // 10% spacing between groups
    
    const allValues = series.flatMap(s => s.values.slice(-6).map(v => Math.abs(v)));
    const maxVal = Math.max(...allValues) || 1;
    
    // Draw zero line if needed
    const hasNegatives = series.some(s => s.values.some(v => v < 0));
    if (hasNegatives) {
      pdf.setDrawColor(100, 100, 100);
      pdf.setLineWidth(0.5);
      const zeroY = chartY + chartHeight / 2;
      pdf.line(chartX, zeroY, chartX + chartWidth, zeroY);
    }
    
    // Draw bars
    for (let i = 0; i < displayLabels.length; i++) {
      for (let j = 0; j < series.length; j++) {
        const value = series[j].values.slice(-6)[i] || 0;
        const absValue = Math.abs(value);
        const barHeight = (absValue / maxVal) * (chartHeight * 0.8);
        
        const barX = chartX + i * barGroupWidth + barSpacing + j * barWidth;
        const barY = chartY + chartHeight - barHeight;
        
        // Skip shadow to avoid dark areas - use series colors only
        
        // Professional bar with full series color - no gradients, no black
        const baseColor = series[j].color;
        const colorRgb = this.hexToRgb(baseColor);
        
        // Fill bar with 100% series color
        pdf.setFillColor(colorRgb.r, colorRgb.g, colorRgb.b);
        pdf.rect(barX, barY, barWidth, barHeight, 'F');
        
        // Optional subtle border with slightly darker shade of same color
        pdf.setDrawColor(Math.max(0, colorRgb.r - 20), Math.max(0, colorRgb.g - 20), Math.max(0, colorRgb.b - 20));
        pdf.setLineWidth(0.3);
        pdf.rect(barX, barY, barWidth, barHeight, 'S');
        
        // Value labels on bars (if space allows) - improved visibility
        if (barHeight > 12) {
          pdf.setTextColor(255, 255, 255); // White text
          pdf.setFontSize(7);
          pdf.setFont('helvetica', 'bold');
          
          // Better currency formatting
          let formattedValue: string;
          const absValue = Math.abs(value);
          
          if (absValue >= 1000000) {
            formattedValue = `${(absValue / 1000000).toFixed(1)}M`;
          } else if (absValue >= 1000) {
            formattedValue = `${(absValue / 1000).toFixed(0)}K`;
          } else {
            formattedValue = absValue.toFixed(0);
          }
          
          pdf.text(formattedValue, barX + barWidth/2, barY + barHeight/2 + 2, { align: 'center' });
        }
      }
    }
    
    // X-axis labels
    const textColorRgb = this.hexToRgb(textColor);
    pdf.setTextColor(textColorRgb.r, textColorRgb.g, textColorRgb.b);
    pdf.setFontSize(7);
    pdf.setFont('helvetica', 'normal');
    
    for (let i = 0; i < displayLabels.length; i++) {
      const labelX = chartX + i * barGroupWidth + barGroupWidth/2;
      
      // Apply same date formatting as other charts for consistency
      let periodLabel = displayLabels[i] || '';
      
      if (locale?.startsWith('es')) {
        // Convert Spanish month names to short form with correct year
        periodLabel = periodLabel
          .replace('enero', 'Ene')
          .replace('febrero', 'Feb')
          .replace('marzo', 'Mar')
          .replace('abril', 'Abr')
          .replace('mayo', 'May')
          .replace('junio', 'Jun')
          .replace('julio', 'Jul')
          .replace('agosto', 'Ago')
          .replace('septiembre', 'Sep')
          .replace('octubre', 'Oct')
          .replace('noviembre', 'Nov')
          .replace('diciembre', 'Dic');
        
        // Extract just the month part (first 3 chars)
        periodLabel = periodLabel.split(' ')[0];
      } else {
        // English month names
        periodLabel = periodLabel
          .replace('January', 'Jan')
          .replace('February', 'Feb')
          .replace('March', 'Mar')
          .replace('April', 'Apr')
          .replace('May', 'May')
          .replace('June', 'Jun')
          .replace('July', 'Jul')
          .replace('August', 'Aug')
          .replace('September', 'Sep')
          .replace('October', 'Oct')
          .replace('November', 'Nov')
          .replace('December', 'Dec');
        
        // Extract just the month part (first 3 chars)
        periodLabel = periodLabel.split(' ')[0];
      }
      
      pdf.text(periodLabel, labelX, chartY + chartHeight + 10, { align: 'center' });
    }
    
    // Y-axis labels with better alignment and formatting
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');
    
    for (let i = 0; i <= 4; i++) {
      const value = (maxVal / 4) * i;
      const labelY = chartY + chartHeight - (i * chartHeight / 4);
      
      // Format currency values with proper abbreviations
      let formattedValue: string;
      const absValue = Math.abs(value);
      
      if (absValue >= 1000000) {
        formattedValue = `${currency}${(absValue / 1000000).toFixed(1)}M`;
      } else if (absValue >= 1000) {
        formattedValue = `${currency}${(absValue / 1000).toFixed(1)}K`;
      } else {
        formattedValue = `${currency}${absValue.toFixed(0)}`;
      }
      
      // Better positioning - align to right edge of chart area
      pdf.text(formattedValue, chartX - 8, labelY + 2, { align: 'right' });
    }
  }

  private hexToRgb(hex: string): { r: number, g: number, b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
}