import { NextRequest, NextResponse } from 'next/server';
import { ProfessionalPDFExportService } from '@/lib/services/professional-pdf-export';
import { getCurrentUser } from '@/lib/auth/server-auth';

// Load translations
async function loadExportTranslations(locale: string) {
  try {
    const translations = await import(`@/locales/${locale}/export.json`);
    return translations.default;
  } catch (error) {
    // Fallback to English
    const translations = await import(`@/locales/en/export.json`);
    return translations.default;
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      dashboardType,
      locale = 'en',
      companyId,
      companyName,
      period,
      filters,
      authToken
    } = body;

    // Validate required parameters
    if (!dashboardType || !companyId) {
      return NextResponse.json(
        { error: 'Missing required parameters: dashboardType, companyId' },
        { status: 400 }
      );
    }

    // Get user info for "Generated By" section
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Fetch complete company and organization data from database
    const { db, companies, organizations, eq } = await import('@/lib/db');
    
    let companyData = null;
    let organizationData = null;
    
    try {
      // Get company details with organization info
      const companyResult = await db
        .select({
          companyId: companies.id,
          companyName: companies.name,
          companyTaxId: companies.taxId,
          companyIndustry: companies.industry,
          companyLocale: companies.locale,
          companyBaseCurrency: companies.baseCurrency,
          companyContactEmail: companies.contactEmail,
          companyWebsite: companies.website,
          organizationId: companies.organizationId,
          organizationName: organizations.name,
          organizationTier: organizations.tier,
          organizationLocale: organizations.locale,
          organizationBaseCurrency: organizations.baseCurrency
        })
        .from(companies)
        .leftJoin(organizations, eq(companies.organizationId, organizations.id))
        .where(eq(companies.id, companyId))
        .limit(1);

      if (companyResult.length === 0) {
        return NextResponse.json(
          { error: 'Company not found' },
          { status: 404 }
        );
      }

      companyData = companyResult[0];
      console.log('✅ Successfully fetched company and organization data');
    } catch (error) {
      console.error('❌ Error fetching company data:', error);
      return NextResponse.json(
        { error: 'Failed to fetch company data' },
        { status: 500 }
      );
    }

    // Fetch dashboard data server-side with authentication
    let dashboardData = null;
    try {
      const apiUrl = dashboardType === 'cashflow' 
        ? `/api/cashflow-live/${companyId}?limit=12`
        : `/api/pnl-live/${companyId}`;
      
      // Make internal API call with same authentication
      const dataResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || 'http://localhost:4000'}${apiUrl}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          // Forward authorization from original request
          ...(request.headers.get('authorization') && {
            'authorization': request.headers.get('authorization')!
          }),
          // Forward cookies for session-based auth
          ...(request.headers.get('cookie') && {
            'cookie': request.headers.get('cookie')!
          })
        }
      });

      if (dataResponse.ok) {
        dashboardData = await dataResponse.json();
        console.log('✅ Successfully fetched dashboard data for export');
      } else {
        console.warn('⚠️ Failed to fetch dashboard data, proceeding with empty export');
      }
    } catch (error) {
      console.error('❌ Error fetching dashboard data for export:', error);
      // Continue with export even if data fetch fails
    }

    // Initialize professional PDF service
    const exportService = new ProfessionalPDFExportService();

    // Get current period from configuration or dashboard data
    let currentPeriod = period;
    if (!currentPeriod && dashboardData?.data?.periods?.length > 0) {
      // Use the last period as current
      currentPeriod = dashboardData.data.periods[dashboardData.data.periods.length - 1];
    }
    if (!currentPeriod) {
      // Fallback to current month
      const now = new Date();
      currentPeriod = now.toLocaleDateString(locale?.startsWith('es') ? 'es-MX' : 'en-US', { 
        month: 'long', 
        year: 'numeric' 
      });
    }

    // Handle different data structures for Cash Flow vs P&L
    let periods, dataRows, financialMetrics;
    
    if (dashboardType === 'cashflow') {
      // Cash Flow data structure
      periods = dashboardData?.data?.periods || [];
      dataRows = dashboardData?.data?.data?.dataRows || {};
      
      financialMetrics = {
        totalInflows: dataRows.totalInflows?.values || [],
        totalOutflows: dataRows.totalOutflows?.values || [],
        netCashFlow: dataRows.netCashFlow?.values || [],
        initialBalance: dataRows.initialBalance?.values || [],
        finalBalance: dataRows.finalBalance?.values || [],
        monthlyGeneration: dataRows.monthlyGeneration?.values || []
      };
    } else {
      // P&L data structure
      periods = dashboardData?.data?.periods || [];
      dataRows = dashboardData?.data?.dataRows || {};
      
      financialMetrics = {
        totalRevenues: dataRows.totalRevenues?.values || [],
        totalCosts: dataRows.totalCosts?.values || [],
        grossProfit: dataRows.grossProfit?.values || [],
        operatingExpenses: dataRows.operatingExpenses?.values || [],
        netIncome: dataRows.netIncome?.values || [],
        ebitda: dataRows.ebitda?.values || []
      };
    }
    
    // Find current period index
    const currentPeriodIndex = periods.findIndex((p: string) => p === currentPeriod);
    const currentIndex = currentPeriodIndex >= 0 ? currentPeriodIndex : periods.length - 1;
    
    // Create summaries based on dashboard type
    let currentMonthSummary, ytdSummary, annualProjections, growthTrends;
    
    if (dashboardType === 'cashflow') {
      // Cash Flow summaries
      currentMonthSummary = {
        balanceInicial: currentIndex >= 0 ? (financialMetrics.initialBalance[currentIndex] || 0) : 0,
        entradasTotales: currentIndex >= 0 ? (financialMetrics.totalInflows[currentIndex] || 0) : 0,
        salidasTotales: currentIndex >= 0 ? Math.abs(financialMetrics.totalOutflows[currentIndex] || 0) : 0,
        balanceFinal: currentIndex >= 0 ? (financialMetrics.finalBalance[currentIndex] || 0) : 0,
        generacionMensual: currentIndex >= 0 ? (financialMetrics.monthlyGeneration[currentIndex] || 0) : 0
      };
      
      const ytdEndIndex = currentIndex >= 0 ? currentIndex + 1 : periods.length;
      ytdSummary = {
        entradasYTD: financialMetrics.totalInflows.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0),
        salidasYTD: financialMetrics.totalOutflows.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + Math.abs(val || 0), 0),
        flujoNetoYTD: financialMetrics.netCashFlow.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0),
        generacionPromMensual: ytdEndIndex > 0 ? 
          financialMetrics.monthlyGeneration.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0) / ytdEndIndex : 0
      };
      
      const monthsInYear = 12;
      const actualMonths = ytdEndIndex;
      const avgInflowPerMonth = actualMonths > 0 ? ytdSummary.entradasYTD / actualMonths : 0;
      const avgOutflowPerMonth = actualMonths > 0 ? ytdSummary.salidasYTD / actualMonths : 0;
      const avgNetFlowPerMonth = actualMonths > 0 ? ytdSummary.flujoNetoYTD / actualMonths : 0;
      
      annualProjections = {
        entradasProyectadas: avgInflowPerMonth * monthsInYear,
        salidasProyectadas: avgOutflowPerMonth * monthsInYear,
        flujoNetoProyectado: avgNetFlowPerMonth * monthsInYear,
        generacionPromProyectada: ytdSummary.generacionPromMensual
      };
      
      growthTrends = periods.map((_: string, index: number) => {
        if (index === 0) return 0;
        const current = financialMetrics.netCashFlow[index] || 0;
        const previous = financialMetrics.netCashFlow[index - 1] || 0;
        return previous !== 0 ? ((current - previous) / Math.abs(previous)) * 100 : 0;
      });
    } else {
      // P&L summaries
      currentMonthSummary = {
        totalRevenues: currentIndex >= 0 ? (financialMetrics.totalRevenues[currentIndex] || 0) : 0,
        totalCosts: currentIndex >= 0 ? (financialMetrics.totalCosts[currentIndex] || 0) : 0,
        grossProfit: currentIndex >= 0 ? (financialMetrics.grossProfit[currentIndex] || 0) : 0,
        operatingExpenses: currentIndex >= 0 ? (financialMetrics.operatingExpenses[currentIndex] || 0) : 0,
        netIncome: currentIndex >= 0 ? (financialMetrics.netIncome[currentIndex] || 0) : 0
      };
      
      const ytdEndIndex = currentIndex >= 0 ? currentIndex + 1 : periods.length;
      ytdSummary = {
        revenuesYTD: financialMetrics.totalRevenues.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0),
        costsYTD: financialMetrics.totalCosts.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0),
        grossProfitYTD: financialMetrics.grossProfit.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0),
        netIncomeYTD: financialMetrics.netIncome.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0),
        avgMonthlyRevenue: ytdEndIndex > 0 ? 
          financialMetrics.totalRevenues.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0) / ytdEndIndex : 0
      };
      
      const monthsInYear = 12;
      const actualMonths = ytdEndIndex;
      const avgRevenuePerMonth = actualMonths > 0 ? ytdSummary.revenuesYTD / actualMonths : 0;
      const avgCostsPerMonth = actualMonths > 0 ? ytdSummary.costsYTD / actualMonths : 0;
      const avgNetIncomePerMonth = actualMonths > 0 ? ytdSummary.netIncomeYTD / actualMonths : 0;
      
      annualProjections = {
        revenuesProyectadas: avgRevenuePerMonth * monthsInYear,
        costsProyectadas: avgCostsPerMonth * monthsInYear,
        netIncomeProyectado: avgNetIncomePerMonth * monthsInYear,
        grossMarginProjected: avgRevenuePerMonth > 0 ? ((avgRevenuePerMonth - avgCostsPerMonth) / avgRevenuePerMonth) * 100 : 0
      };
      
      growthTrends = periods.map((_: string, index: number) => {
        if (index === 0) return 0;
        const current = financialMetrics.netIncome[index] || 0;
        const previous = financialMetrics.netIncome[index - 1] || 0;
        return previous !== 0 ? ((current - previous) / Math.abs(previous)) * 100 : 0;
      });
    }
    
    // Transform dashboard data for comprehensive export
    const exportData = {
      // Company & Organization Info
      companyName: companyData?.companyName || companyName || 'Company Name',
      organizationName: companyData?.organizationName || 'Organization Name',
      companyTaxId: companyData?.companyTaxId || '',
      industry: companyData?.companyIndustry || '',
      contactEmail: companyData?.companyContactEmail || '',
      website: companyData?.companyWebsite || '',
      
      // Report Meta Data
      reportType: dashboardType as 'pnl' | 'cashflow',
      locale: locale || companyData?.companyLocale || 'en-US',
      currency: companyData?.companyBaseCurrency || 'USD',
      currentPeriod,
      currentPeriodIndex: currentIndex,
      generatedBy: `${user.firstName} ${user.lastName}`,
      generatedAt: new Date().toISOString(),
      lastUpdate: dashboardData?.data?.lastUpdated || new Date().toISOString(),
      
      // Financial Data Arrays (depends on dashboard type)
      periods,
      ...(dashboardType === 'cashflow' ? {
        totalInflows: { values: financialMetrics.totalInflows },
        totalOutflows: { values: financialMetrics.totalOutflows },
        netCashFlow: { values: financialMetrics.netCashFlow },
        initialBalance: { values: financialMetrics.initialBalance },
        finalBalance: { values: financialMetrics.finalBalance },
        monthlyGeneration: { values: financialMetrics.monthlyGeneration }
      } : {
        totalRevenues: { values: financialMetrics.totalRevenues },
        totalCosts: { values: financialMetrics.totalCosts },
        grossProfit: { values: financialMetrics.grossProfit },
        operatingExpenses: { values: financialMetrics.operatingExpenses },
        netIncome: { values: financialMetrics.netIncome },
        ebitda: { values: financialMetrics.ebitda }
      }),
      
      // Calculated Summaries
      currentMonthSummary,
      ytdSummary,
      annualProjections,
      growthTrends,
      
      // Enhanced Data (if available from dashboard)
      yearToDate: dashboardData?.data?.yearToDate || {},
      projectedAnnual: dashboardData?.data?.projectedAnnual || {},
      categories: dashboardData?.data?.categories || {},
      forecasts: dashboardData?.data?.forecasts || {},
      
      // All line items for detailed breakdown
      lineItems: dataRows,
      
      // Summary metrics
      summary: dashboardData?.data?.summary || {},
      
      // Configuration data for actual/forecast determination
      lastActualPeriod: dashboardData?.data?.data?.metadata?.lastActualPeriod,
      lastActualPeriodLabel: dashboardData?.data?.data?.metadata?.lastActualPeriodLabel,
      periodMetadata: dashboardData?.data?.periodMetadata || {}
    };

    // Generate PDF
    const pdfBuffer = await exportService.generateProfessionalPDF(exportData);

    // Generate localized filename
    const date = new Date().toISOString().split('T')[0];
    const filename = dashboardType === 'cashflow' 
      ? (locale.startsWith('es') ? `flujo-caja-${date}.pdf` : `cash-flow-${date}.pdf`)
      : (locale.startsWith('es') ? `estado-resultados-${date}.pdf` : `profit-loss-${date}.pdf`);

    // Return PDF with proper headers
    return new Response(pdfBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': pdfBuffer.length.toString(),
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      }
    });

  } catch (error) {
    console.error('PDF export error:', error);
    
    // Return appropriate error based on error type
    if (error instanceof Error) {
      if (error.message.includes('timeout')) {
        return NextResponse.json(
          { error: 'Export timeout. Please try again.' },
          { status: 408 }
        );
      }
      if (error.message.includes('network') || error.message.includes('ECONNREFUSED')) {
        return NextResponse.json(
          { error: 'Network error during export' },
          { status: 503 }
        );
      }
    }

    return NextResponse.json(
      { error: 'Failed to generate PDF export' },
      { status: 500 }
    );
  }
}

// GET method for health check
export async function GET() {
  return NextResponse.json({
    service: 'PDF Export',
    status: 'available',
    timestamp: new Date().toISOString()
  });
}