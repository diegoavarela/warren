export interface CsvExportData {
  // Company & Organization Info
  companyName: string;
  organizationName: string;
  companyTaxId?: string;
  industry?: string;
  contactEmail?: string;
  website?: string;
  
  // Report Meta Data
  reportType: 'pnl' | 'cashflow';
  locale: string;
  currency: string;
  currentPeriod: string;
  currentPeriodIndex: number;
  generatedBy: string;
  generatedAt: string;
  lastUpdate: string;
  
  // Financial Data Arrays
  periods: string[];
  
  // Dynamic financial metrics based on report type
  [key: string]: any;
  
  // Calculated Summaries
  currentMonthSummary: any;
  ytdSummary: any;
  annualProjections: any;
  growthTrends: number[];
  
  // Enhanced Data
  lineItems?: any;
}

export class CsvExportService {
  
  /**
   * Generate a CSV export of financial dashboard data
   */
  async generateCsvExport(data: CsvExportData): Promise<Buffer> {
    const csvLines: string[] = [];
    
    // Add metadata header
    csvLines.push('# Warren Financial Dashboard Export');
    csvLines.push(`# Company: ${data.companyName}`);
    csvLines.push(`# Report Type: ${data.reportType.toUpperCase()}`);
    csvLines.push(`# Export Date: ${data.generatedAt}`);
    csvLines.push(`# Generated By: ${data.generatedBy}`);
    csvLines.push(`# Currency: ${data.currency}`);
    csvLines.push('');
    
    // Add main financial data table
    this.addMainDataSection(csvLines, data);
    
    // Add summaries section
    this.addSummariesSection(csvLines, data);
    
    // Add growth trends
    this.addGrowthTrendsSection(csvLines, data);
    
    // Add detailed line items if available
    if (data.lineItems) {
      this.addLineItemsSection(csvLines, data);
    }
    
    // Convert to buffer
    const csvContent = csvLines.join('\n');
    return Buffer.from(csvContent, 'utf-8');
  }
  
  /**
   * Add main financial data section
   */
  private addMainDataSection(csvLines: string[], data: CsvExportData): void {
    csvLines.push('## Main Financial Data');
    
    // Create header row with periods
    const header = ['Metric', ...data.periods];
    csvLines.push(this.escapeCsvRow(header));
    
    if (data.reportType === 'cashflow') {
      // Cash flow metrics
      this.addDataRow(csvLines, 'Total Inflows', data.totalInflows?.values || [], data.currency);
      this.addDataRow(csvLines, 'Total Outflows', data.totalOutflows?.values || [], data.currency);
      this.addDataRow(csvLines, 'Net Cash Flow', data.netCashFlow?.values || [], data.currency);
      this.addDataRow(csvLines, 'Initial Balance', data.initialBalance?.values || [], data.currency);
      this.addDataRow(csvLines, 'Final Balance', data.finalBalance?.values || [], data.currency);
      this.addDataRow(csvLines, 'Monthly Generation', data.monthlyGeneration?.values || [], data.currency);
    } else {
      // P&L metrics
      this.addDataRow(csvLines, 'Total Revenues', data.totalRevenues?.values || [], data.currency);
      this.addDataRow(csvLines, 'Total Costs', data.totalCosts?.values || [], data.currency);
      this.addDataRow(csvLines, 'Gross Profit', data.grossProfit?.values || [], data.currency);
      this.addDataRow(csvLines, 'Operating Expenses', data.operatingExpenses?.values || [], data.currency);
      this.addDataRow(csvLines, 'Net Income', data.netIncome?.values || [], data.currency);
      if (data.ebitda?.values) {
        this.addDataRow(csvLines, 'EBITDA', data.ebitda.values, data.currency);
      }
    }
    
    csvLines.push('');
  }
  
  /**
   * Add summaries section
   */
  private addSummariesSection(csvLines: string[], data: CsvExportData): void {
    csvLines.push('## Summary Data');
    csvLines.push('Category,Current Period,YTD,Annual Projection');
    
    const currentSummary = data.currentMonthSummary || {};
    const ytdSummary = data.ytdSummary || {};
    const projections = data.annualProjections || {};
    
    if (data.reportType === 'cashflow') {
      this.addSummaryRow(csvLines, 'Inflows', 
        currentSummary.entradasTotales, 
        ytdSummary.entradasYTD, 
        projections.entradasProyectadas,
        data.currency);
      this.addSummaryRow(csvLines, 'Outflows', 
        currentSummary.salidasTotales, 
        ytdSummary.salidasYTD, 
        projections.salidasProyectadas,
        data.currency);
      this.addSummaryRow(csvLines, 'Net Flow', 
        currentSummary.generacionMensual, 
        ytdSummary.flujoNetoYTD, 
        projections.flujoNetoProyectado,
        data.currency);
      this.addSummaryRow(csvLines, 'Final Balance', 
        currentSummary.balanceFinal, 
        null, 
        null,
        data.currency);
    } else {
      this.addSummaryRow(csvLines, 'Revenues', 
        currentSummary.totalRevenues, 
        ytdSummary.revenuesYTD, 
        projections.revenuesProyectadas,
        data.currency);
      this.addSummaryRow(csvLines, 'Costs', 
        currentSummary.totalCosts, 
        ytdSummary.costsYTD, 
        projections.costsProyectadas,
        data.currency);
      this.addSummaryRow(csvLines, 'Gross Profit', 
        currentSummary.grossProfit, 
        ytdSummary.grossProfitYTD, 
        null,
        data.currency);
      this.addSummaryRow(csvLines, 'Net Income', 
        currentSummary.netIncome, 
        ytdSummary.netIncomeYTD, 
        projections.netIncomeProyectado,
        data.currency);
    }
    
    csvLines.push('');
  }
  
  /**
   * Add growth trends section
   */
  private addGrowthTrendsSection(csvLines: string[], data: CsvExportData): void {
    if (!data.growthTrends || data.growthTrends.length === 0) return;
    
    csvLines.push('## Growth Trends (%)');
    const header = ['Period', 'Growth Rate'];
    csvLines.push(this.escapeCsvRow(header));
    
    data.periods.forEach((period, index) => {
      if (index < data.growthTrends.length) {
        const growthRate = data.growthTrends[index];
        csvLines.push(this.escapeCsvRow([period, this.formatPercentage(growthRate)]));
      }
    });
    
    csvLines.push('');
  }
  
  /**
   * Add detailed line items section
   */
  private addLineItemsSection(csvLines: string[], data: CsvExportData): void {
    csvLines.push('## Detailed Line Items');
    
    const lineItems = data.lineItems;
    if (!lineItems || typeof lineItems !== 'object') return;
    
    // Create header with periods
    const header = ['Line Item', ...data.periods];
    csvLines.push(this.escapeCsvRow(header));
    
    // Add each line item
    Object.entries(lineItems).forEach(([key, item]: [string, any]) => {
      if (item?.values && Array.isArray(item.values)) {
        const label = item.label || this.formatLineItemLabel(key);
        this.addDataRow(csvLines, label, item.values, data.currency);
      }
    });
  }
  
  /**
   * Add a data row with proper formatting
   */
  private addDataRow(csvLines: string[], label: string, values: number[], currency: string): void {
    const formattedValues = values.map(value => this.formatCurrency(value, currency));
    const row = [label, ...formattedValues];
    csvLines.push(this.escapeCsvRow(row));
  }
  
  /**
   * Add a summary row
   */
  private addSummaryRow(csvLines: string[], label: string, current: number, ytd: number | null, projection: number | null, currency: string): void {
    const row = [
      label,
      this.formatCurrency(current, currency),
      ytd !== null ? this.formatCurrency(ytd, currency) : '',
      projection !== null ? this.formatCurrency(projection, currency) : ''
    ];
    csvLines.push(this.escapeCsvRow(row));
  }
  
  /**
   * Escape and format a CSV row
   */
  private escapeCsvRow(row: string[]): string {
    return row.map(cell => {
      const cellStr = String(cell || '');
      // Escape quotes and wrap in quotes if contains comma, quote, or newline
      if (cellStr.includes(',') || cellStr.includes('"') || cellStr.includes('\n')) {
        return '"' + cellStr.replace(/"/g, '""') + '"';
      }
      return cellStr;
    }).join(',');
  }
  
  /**
   * Format currency values
   */
  private formatCurrency(value: number | undefined | null, currency: string): string {
    if (value === null || value === undefined || isNaN(value)) {
      return '0';
    }
    
    // Return numeric value for CSV (easier to import into spreadsheets)
    return value.toFixed(2);
  }
  
  /**
   * Format percentage values
   */
  private formatPercentage(value: number | undefined | null): string {
    if (value === null || value === undefined || isNaN(value)) {
      return '0.00%';
    }
    
    return value.toFixed(2) + '%';
  }
  
  /**
   * Format line item labels
   */
  private formatLineItemLabel(key: string): string {
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .trim();
  }
}