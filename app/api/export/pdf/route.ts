import { NextRequest, NextResponse } from 'next/server';
import { ProfessionalPDFExportService } from '@/lib/services/professional-pdf-export';
import { getCurrentUser } from '@/lib/auth/server-auth';

// Load translations
async function loadExportTranslations(locale: string) {
  try {
    const translations = await import(`@/locales/${locale}/export.json`);
    return translations.default;
  } catch (error) {
    // Fallback to English
    const translations = await import(`@/locales/en/export.json`);
    return translations.default;
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      dashboardType,
      locale = 'en',
      companyId,
      companyName,
      period,
      filters,
      authToken
    } = body;

    // Validate required parameters
    if (!dashboardType || !companyId) {
      return NextResponse.json(
        { error: 'Missing required parameters: dashboardType, companyId' },
        { status: 400 }
      );
    }

    // Get user info for "Generated By" section
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Fetch complete company and organization data from database
    const { db, companies, organizations, eq } = await import('@/lib/db');
    
    let companyData = null;
    let organizationData = null;
    
    try {
      // Get company details with organization info
      const companyResult = await db
        .select({
          companyId: companies.id,
          companyName: companies.name,
          companyTaxId: companies.taxId,
          companyIndustry: companies.industry,
          companyLocale: companies.locale,
          companyBaseCurrency: companies.baseCurrency,
          companyContactEmail: companies.contactEmail,
          companyWebsite: companies.website,
          organizationId: companies.organizationId,
          organizationName: organizations.name,
          organizationTier: organizations.tier,
          organizationLocale: organizations.locale,
          organizationBaseCurrency: organizations.baseCurrency
        })
        .from(companies)
        .leftJoin(organizations, eq(companies.organizationId, organizations.id))
        .where(eq(companies.id, companyId))
        .limit(1);

      if (companyResult.length === 0) {
        return NextResponse.json(
          { error: 'Company not found' },
          { status: 404 }
        );
      }

      companyData = companyResult[0];
      console.log('✅ Successfully fetched company and organization data');
    } catch (error) {
      console.error('❌ Error fetching company data:', error);
      return NextResponse.json(
        { error: 'Failed to fetch company data' },
        { status: 500 }
      );
    }

    // Fetch dashboard data server-side with authentication
    let dashboardData = null;
    try {
      const apiUrl = dashboardType === 'cashflow' 
        ? `/api/cashflow-live/${companyId}?limit=12`
        : `/api/processed-data/pnl/${companyId}`;
      
      // Make internal API call with same authentication
      const dataResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || 'http://localhost:4000'}${apiUrl}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          // Forward authorization from original request
          ...(request.headers.get('authorization') && {
            'authorization': request.headers.get('authorization')!
          }),
          // Forward cookies for session-based auth
          ...(request.headers.get('cookie') && {
            'cookie': request.headers.get('cookie')!
          })
        }
      });

      if (dataResponse.ok) {
        dashboardData = await dataResponse.json();
        console.log('✅ Successfully fetched dashboard data for export');
      } else {
        console.warn('⚠️ Failed to fetch dashboard data, proceeding with empty export');
      }
    } catch (error) {
      console.error('❌ Error fetching dashboard data for export:', error);
      // Continue with export even if data fetch fails
    }

    // Initialize professional PDF service
    const exportService = new ProfessionalPDFExportService();

    // Get current period from configuration or dashboard data
    let currentPeriod = period;
    if (!currentPeriod && dashboardData?.data?.periods?.length > 0) {
      // Use the last period as current
      currentPeriod = dashboardData.data.periods[dashboardData.data.periods.length - 1];
    }
    if (!currentPeriod) {
      // Fallback to current month
      const now = new Date();
      currentPeriod = now.toLocaleDateString(locale?.startsWith('es') ? 'es-MX' : 'en-US', { 
        month: 'long', 
        year: 'numeric' 
      });
    }

    // Calculate comprehensive metrics from dashboard data
    const periods = dashboardData?.data?.periods || [];
    const dataRows = dashboardData?.data?.data?.dataRows || {};
    
    // Get financial data arrays
    const totalInflows = dataRows.totalInflows?.values || [];
    const totalOutflows = dataRows.totalOutflows?.values || [];
    const netCashFlow = dataRows.netCashFlow?.values || [];
    const initialBalance = dataRows.initialBalance?.values || [];
    const finalBalance = dataRows.finalBalance?.values || [];
    const monthlyGeneration = dataRows.monthlyGeneration?.values || [];
    
    // Find current period index
    const currentPeriodIndex = periods.findIndex((p: string) => p === currentPeriod);
    const currentIndex = currentPeriodIndex >= 0 ? currentPeriodIndex : periods.length - 1;
    
    // Current Month Summary
    const currentMonthSummary = {
      balanceInicial: currentIndex >= 0 ? (initialBalance[currentIndex] || 0) : 0,
      entradasTotales: currentIndex >= 0 ? (totalInflows[currentIndex] || 0) : 0,
      salidasTotales: currentIndex >= 0 ? Math.abs(totalOutflows[currentIndex] || 0) : 0,
      balanceFinal: currentIndex >= 0 ? (finalBalance[currentIndex] || 0) : 0,
      generacionMensual: currentIndex >= 0 ? (monthlyGeneration[currentIndex] || 0) : 0
    };
    
    // YTD Summary (sum up to current period)
    const ytdEndIndex = currentIndex >= 0 ? currentIndex + 1 : periods.length;
    const ytdSummary = {
      entradasYTD: totalInflows.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0),
      salidasYTD: totalOutflows.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + Math.abs(val || 0), 0),
      flujoNetoYTD: netCashFlow.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0),
      generacionPromMensual: ytdEndIndex > 0 ? 
        monthlyGeneration.slice(0, ytdEndIndex).reduce((sum: number, val: number) => sum + (val || 0), 0) / ytdEndIndex : 0
    };
    
    // Annual Projections (based on YTD averages)
    const monthsInYear = 12;
    const actualMonths = ytdEndIndex;
    const avgInflowPerMonth = actualMonths > 0 ? ytdSummary.entradasYTD / actualMonths : 0;
    const avgOutflowPerMonth = actualMonths > 0 ? ytdSummary.salidasYTD / actualMonths : 0;
    const avgNetFlowPerMonth = actualMonths > 0 ? ytdSummary.flujoNetoYTD / actualMonths : 0;
    
    const annualProjections = {
      entradasProyectadas: avgInflowPerMonth * monthsInYear,
      salidasProyectadas: avgOutflowPerMonth * monthsInYear,
      flujoNetoProyectado: avgNetFlowPerMonth * monthsInYear,
      generacionPromProyectada: ytdSummary.generacionPromMensual
    };
    
    // Calculate growth trends for charts
    const growthTrends = periods.map((_: string, index: number) => {
      if (index === 0) return 0;
      const current = netCashFlow[index] || 0;
      const previous = netCashFlow[index - 1] || 0;
      return previous !== 0 ? ((current - previous) / Math.abs(previous)) * 100 : 0;
    });
    
    // Transform dashboard data for comprehensive export
    const exportData = {
      // Company & Organization Info
      companyName: companyData?.companyName || companyName || 'Company Name',
      organizationName: companyData?.organizationName || 'Organization Name',
      companyTaxId: companyData?.companyTaxId || '',
      industry: companyData?.companyIndustry || '',
      contactEmail: companyData?.companyContactEmail || '',
      website: companyData?.companyWebsite || '',
      
      // Report Meta Data
      reportType: dashboardType as 'pnl' | 'cashflow',
      locale: locale || companyData?.companyLocale || 'en-US',
      currency: companyData?.companyBaseCurrency || 'USD',
      currentPeriod,
      currentPeriodIndex: currentIndex,
      generatedBy: `${user.firstName} ${user.lastName}`,
      generatedAt: new Date().toISOString(),
      lastUpdate: dashboardData?.data?.lastUpdated || new Date().toISOString(),
      
      // Financial Data Arrays
      periods,
      totalInflows: { values: totalInflows },
      totalOutflows: { values: totalOutflows },
      netCashFlow: { values: netCashFlow },
      initialBalance: { values: initialBalance },
      finalBalance: { values: finalBalance },
      monthlyGeneration: { values: monthlyGeneration },
      
      // Calculated Summaries
      currentMonthSummary,
      ytdSummary,
      annualProjections,
      growthTrends,
      
      // Enhanced Data (if available from dashboard)
      yearToDate: dashboardData?.data?.yearToDate || {},
      projectedAnnual: dashboardData?.data?.projectedAnnual || {},
      categories: dashboardData?.data?.categories || {},
      forecasts: dashboardData?.data?.forecasts || {},
      
      // All line items for detailed breakdown
      lineItems: dataRows,
      
      // Summary metrics
      summary: dashboardData?.data?.summary || {},
      
      // Configuration data for actual/forecast determination
      lastActualPeriod: dashboardData?.data?.data?.metadata?.lastActualPeriod,
      lastActualPeriodLabel: dashboardData?.data?.data?.metadata?.lastActualPeriodLabel,
      periodMetadata: dashboardData?.data?.periodMetadata || {}
    };

    // Generate PDF
    const pdfBuffer = await exportService.generateProfessionalPDF(exportData);

    // Generate localized filename
    const date = new Date().toISOString().split('T')[0];
    const filename = dashboardType === 'cashflow' 
      ? (locale.startsWith('es') ? `flujo-caja-${date}.pdf` : `cash-flow-${date}.pdf`)
      : (locale.startsWith('es') ? `estado-resultados-${date}.pdf` : `profit-loss-${date}.pdf`);

    // Return PDF with proper headers
    return new Response(pdfBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': pdfBuffer.length.toString(),
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      }
    });

  } catch (error) {
    console.error('PDF export error:', error);
    
    // Return appropriate error based on error type
    if (error instanceof Error) {
      if (error.message.includes('timeout')) {
        return NextResponse.json(
          { error: 'Export timeout. Please try again.' },
          { status: 408 }
        );
      }
      if (error.message.includes('network') || error.message.includes('ECONNREFUSED')) {
        return NextResponse.json(
          { error: 'Network error during export' },
          { status: 503 }
        );
      }
    }

    return NextResponse.json(
      { error: 'Failed to generate PDF export' },
      { status: 500 }
    );
  }
}

// GET method for health check
export async function GET() {
  return NextResponse.json({
    service: 'PDF Export',
    status: 'available',
    timestamp: new Date().toISOString()
  });
}